"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _LocaleInfo = _interopRequireDefault(require("ilib/lib/LocaleInfo"));

var _locale = require("../locale");

var _excluded = ["latinLanguageOverrides", "nonLatinLanguageOverrides"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var base = 'enact-locale-'; // Callback-friendly version of Promise.all()

function all(fns, callback) {
  var result = [];
  var complete = 0;

  var done = function done(index) {
    return function (value) {
      result[index] = value;
      complete++;

      if (complete === fns.length) {
        callback(result);
      }
    };
  };

  fns.forEach(function (fn, index) {
    return fn(done(index));
  });
}

function getClassesForLocale(li, options) {
  var locale = li.getLocale();

  var latinLanguageOverrides = options.latinLanguageOverrides,
      nonLatinLanguageOverrides = options.nonLatinLanguageOverrides,
      rest = _objectWithoutProperties(options, _excluded);

  all([// allow enact to define other fonts for non-Latin languages, or for certain
  // Latin-based languages where the characters with some accents don't appear in the
  // regular fonts, creating a strange 'ransom note' look with a mix of fonts in the
  // same word. So, treat it like a non-Latin language in order to get all the characters
  // to display with the same font.
  function (done) {
    return (0, _locale.isNonLatinLocale)(locale, _objectSpread(_objectSpread({}, rest), {}, {
      latinLanguageOverrides: latinLanguageOverrides,
      nonLatinLanguageOverrides: nonLatinLanguageOverrides,
      onLoad: function onLoad(isNonLatin) {
        return done(isNonLatin ? base + 'non-latin' : '');
      }
    }));
  }, // allow enact to apply right-to-left styles to the app and widgets if necessary
  function (done) {
    return (0, _locale.isRtlLocale)(_objectSpread(_objectSpread({}, rest), {}, {
      onLoad: function onLoad(isRtl) {
        return done(isRtl ? base + 'right-to-left' : '');
      }
    }));
  }], function (classes) {
    var scriptName = li.getScript();

    if (scriptName !== 'Latn' && scriptName !== 'Cyrl' && scriptName !== 'Grek' && scriptName !== 'Kore') {
      // GF-45884: allow enact to avoid setting italic fonts for those scripts that do not
      // commonly use italics
      classes.push(base + 'non-italic');
    } // allow enact or the apps to give CSS classes that are specific to the language, country, or script


    if (locale.getLanguage()) {
      classes.push(base + locale.getLanguage());

      if (locale.getScript()) {
        classes.push(base + locale.getLanguage() + '-' + locale.getScript());

        if (locale.getRegion()) {
          classes.push(base + locale.getLanguage() + '-' + locale.getScript() + '-' + locale.getRegion());
        }
      } else if (locale.getRegion()) {
        classes.push(base + locale.getLanguage() + '-' + locale.getRegion());
      }
    }

    if (locale.getScript()) {
      classes.push(base + locale.getScript());
    }

    if (locale.getRegion()) {
      classes.push(base + locale.getRegion());
    }

    options.onLoad(classes.filter(Boolean).join(' '));
  });
}
/*
 * A function that returns locale in class name.
 *
 * @memberof i18n/I18nDecorator
 * @param {options.sync} Perform a synchronous request for the classes
 * @param {options.onLoad} Called with a string of i18n classes
 * @param {options.latinLanguageOverrides} Array of locales to treat as latin
 * @param {options.nonLatinLanguageOverrides} Array of locales to treat as non-latin
 * @private
 */


function getI18nClasses() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var sync = options.sync,
      _onLoad = options.onLoad;
  if (!_onLoad) return; // eslint-disable-next-line no-new,no-undefined

  new _LocaleInfo["default"](undefined, {
    sync: sync,
    onLoad: function onLoad(li) {
      return getClassesForLocale(li, _objectSpread(_objectSpread({}, options), {}, {
        onLoad: _onLoad
      }));
    }
  }); // for the current locale
}

var _default = getI18nClasses;
exports["default"] = _default;