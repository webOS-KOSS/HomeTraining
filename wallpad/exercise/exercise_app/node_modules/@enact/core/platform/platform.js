"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.platform = exports.parseUserAgent = exports.detect = exports["default"] = void 0;

var _uniq = _interopRequireDefault(require("ramda/src/uniq"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var hasGesture = function hasGesture() {
  return Boolean('ongesturestart' in window || 'onmsgesturestart' in window && (window.navigator.msMaxTouchPoints > 1 || window.navigator.maxTouchPoints > 1));
};

var hasTouch = function hasTouch() {
  return Boolean('TouchEvent' in window || 'ontouchstart' in window || window.navigator.msMaxTouchPoints || window.navigator.msManipulationViewsEnabled && window.navigator.maxTouchPoints);
}; // Adapted from https://patrickhlauke.github.io/touch/touchscreen-detection/
// I've omitted the touch event fallback since that is covered by hasTouch and we're less concerned
// with legacy browsers used in touchscreen environments.


var hasTouchScreen = function hasTouchScreen() {
  return (// if Pointer Events are supported, just check maxTouchPoints
    window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints > 0 || // check for any-pointer:coarse which mostly means touchscreen
    window.matchMedia && window.matchMedia('(any-pointer:coarse)').matches
  );
};

var webOSVersion = {
  38: 3,
  53: 4,
  68: 5,
  79: 6
};
var platforms = [// Windows Phone 7 - 10
{
  platform: 'windowsPhone',
  regex: /Windows Phone (?:OS )?(\d+)[.\d]+/
}, // Android 4+ using Chrome
{
  platform: 'androidChrome',
  regex: /Android .* Chrome\/(\d+)[.\d]+/
}, // Android 2 - 4
{
  platform: 'android',
  regex: /Android(?:\s|\/)(\d+)/
}, // Kindle Fire
// Force version to 2, (desktop mode does not list android version)
{
  platform: 'android',
  regex: /Silk\/1./,
  forceVersion: 2,
  extra: {
    silk: 1
  }
}, // Kindle Fire HD (Silk versions 2 or 3)
// Force version to 4
{
  platform: 'android',
  regex: /Silk\/2./,
  forceVersion: 4,
  extra: {
    silk: 2
  }
}, {
  platform: 'android',
  regex: /Silk\/3./,
  forceVersion: 4,
  extra: {
    silk: 3
  }
}, // IE 8 - 10
{
  platform: 'ie',
  regex: /MSIE (\d+)/
}, // IE 11
{
  platform: 'ie',
  regex: /Trident\/.*; rv:(\d+)/
}, // Edge
{
  platform: 'edge',
  regex: /Edge\/(\d+)/
}, // iOS 3 - 5
// Apple likes to make this complicated
{
  platform: 'ios',
  regex: /iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/
}, // LG webOS
{
  platform: 'webos',
  regex: /Web0S;.*Safari\/537.41/,
  forceVersion: 1
}, {
  platform: 'webos',
  regex: /Web0S;.*Safari\/538.2/,
  forceVersion: 2
}, {
  platform: 'webos',
  regex: /Web0S;.*Chrome\/(\d+)/
}, // LG webOS of indeterminate versionre
{
  platform: 'webos',
  regex: /Web0S;/,
  forceVersion: -1
}, // LuneOS
{
  platform: 'webos',
  regex: /LuneOS/,
  forceVersion: -1,
  extra: {
    luneos: 1
  }
}, // Palm/HP/Open webOS
{
  platform: 'webos',
  regex: /WebAppManager|Isis|webOS\./,
  forceVersion: -1,
  extra: {
    legacy: 4
  }
}, {
  platform: 'webos',
  regex: /(?:web|hpw)OS\/1/,
  forceVersion: -1,
  extra: {
    legacy: 1
  }
}, {
  platform: 'webos',
  regex: /(?:web|hpw)OS\/2/,
  forceVersion: -1,
  extra: {
    legacy: 2
  }
}, {
  platform: 'webos',
  regex: /(?:web|hpw)OS\/3/,
  forceVersion: -1,
  extra: {
    legacy: 3
  }
}, // desktop Safari
{
  platform: 'safari',
  regex: /Version\/(\d+)[.\d]+\s+Safari/
}, // desktop Chrome
{
  platform: 'chrome',
  regex: /Chrome\/(\d+)[.\d]+/
}, // Firefox on Android
{
  platform: 'androidFirefox',
  regex: /Android;.*Firefox\/(\d+)/
}, // FirefoxOS
{
  platform: 'firefoxOS',
  regex: /Mobile;.*Firefox\/(\d+)/
}, // desktop Firefox
{
  platform: 'firefox',
  regex: /Firefox\/(\d+)/
}, // Blackberry Playbook
{
  platform: 'blackberry',
  regex: /PlayBook/i,
  forceVersion: 2
}, // Blackberry 10+
{
  platform: 'blackberry',
  regex: /BB1\d;.*Version\/(\d+\.\d+)/
}, // Tizen
{
  platform: 'tizen',
  regex: /Tizen (\d+)/
}];

var ua = function ua() {
  return window.navigator ? window.navigator.userAgent : '';
};

var _platform;

var parseUserAgent = function parseUserAgent(userAgent) {
  var plat = {
    gesture: hasGesture(),
    node: false,
    touch: hasTouch(),
    touchscreen: hasTouchScreen(),
    unknown: true
  };

  for (var i = 0, p, m, v; p = platforms[i]; i++) {
    m = p.regex.exec(userAgent);

    if (m) {
      plat.unknown = false;

      if ('forceVersion' in p) {
        v = p.forceVersion;
      } else if (p.platform === 'webos') {
        v = webOSVersion[m[1]] || -1;

        if (v >= 7 || v === -1) {
          plat.chrome = Number(m[1]);
        }
      } else {
        v = Number(m[1]);
      }

      plat[p.platform] = v;

      if (p.extra) {
        plat = _objectSpread(_objectSpread({}, plat), p.extra);
      }

      plat.platformName = p.platform;
      break;
    }
  }

  return plat;
};
/**
 * @typedef {Object} PlatformDescription
 * @property {Object} [extra] - Additional information about the detected platform
 * @property {Boolean} gesture - `true` if the platform has native double-finger events
 * @property {Boolean} node - `true` only if `window` is `undefined`
 * @property {String} [platformName] - The name of the platform, if detected
 * @property {Boolean} touch - `true` if the platform has native single-finger events
 * @property {Boolean} touchscreen - `true` if the platform has a touch screen
 * @property {Boolean} unknown - `true` for any unknown system
 *
 * @memberof core/platform
 * @public
 */

/**
 * Returns the {@link core/platform.platform} object.
 *
 * @function detect
 * @returns {PlatformDescription}     The {@link core/platform.platform} object
 * @memberof core/platform
 * @public
 */


exports.parseUserAgent = parseUserAgent;

var detect = function detect() {
  if (_platform) {
    // if we've already determined the platform, we'll use that determination
    return _platform;
  } else if (typeof window === 'undefined') {
    return {
      gesture: false,
      node: true,
      touch: false,
      unknown: true
    };
  }

  var userAgent = ua();
  return _platform = parseUserAgent(userAgent);
};
/**
 * Provides basic information about the running platform.
 *
 * @type {PlatformDescription}
 * @memberof core/platform
 * @public
 */


exports.detect = detect;
var platform = {};
exports.platform = platform;
['gesture', 'node', 'platformName', 'touch', 'touchscreen', 'unknown'].concat(_toConsumableArray((0, _uniq["default"])(platforms.map(function (p) {
  return p.platform;
})))).forEach(function (name) {
  Object.defineProperty(platform, name, {
    enumerable: true,
    get: function get() {
      var p = detect();
      return p[name];
    }
  });
});
var _default = platform;
exports["default"] = _default;