"use strict";

var _handle = require("../handle");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

describe('handle', function () {
  var makeEvent = function makeEvent(payload) {
    return _objectSpread({
      preventDefault: jest.fn(),
      stopPropagation: jest.fn()
    }, payload);
  };

  var returnsTrue = function returnsTrue() {
    return true;
  };

  var returnsFalse = function returnsFalse() {
    return false;
  };

  test('should call only handler', function () {
    var handler = jest.fn(returnsTrue);
    var callback = (0, _handle.handle)(handler);
    callback(makeEvent());
    var expected = 1;
    expect(handler).toHaveBeenCalledTimes(expected);
  });
  test('should call multiple handlers', function () {
    var handler1 = jest.fn(returnsTrue);
    var handler2 = jest.fn(returnsTrue);
    var callback = (0, _handle.handle)(handler1, handler2);
    callback(makeEvent());
    var expected = 1;
    expect(handler1).toHaveBeenCalledTimes(expected);
    expect(handler2).toHaveBeenCalledTimes(expected);
  });
  test('should skip non-function handlers', function () {
    var handler = jest.fn(returnsTrue);
    var callback = (0, _handle.handle)(null, void 0, 0, 'purple', handler);
    callback(makeEvent());
    var expected = 1;
    expect(handler).toHaveBeenCalledTimes(expected);
  });
  test('should not call handlers after one that returns false', function () {
    var handler1 = jest.fn(returnsTrue);
    var handler2 = jest.fn(returnsTrue);
    var callback = (0, _handle.handle)(handler1, returnsFalse, handler2);
    callback(makeEvent());
    var expectedFirst = 1;
    expect(handler1).toHaveBeenCalledTimes(expectedFirst);
    expect(handler2).not.toHaveBeenCalled();
  });
  test('should call stopPropagation on event', function () {
    var callback = (0, _handle.handle)(_handle.stop);
    var ev = makeEvent();
    callback(ev);
    var expected = 1;
    var actual = ev.stopPropagation;
    expect(actual).toHaveBeenCalledTimes(expected);
  });
  test('should call preventDefault on event', function () {
    var callback = (0, _handle.handle)(_handle.preventDefault);
    var ev = makeEvent();
    callback(ev);
    var expected = 1;
    var actual = ev.preventDefault;
    expect(actual).toHaveBeenCalledTimes(expected);
  });
  test('should call any method on event', function () {
    var callback = (0, _handle.handle)((0, _handle.callOnEvent)('customMethod'));
    var ev = makeEvent({
      customMethod: jest.fn()
    });
    callback(ev);
    var expected = 1;
    var actual = ev.customMethod;
    expect(actual).toHaveBeenCalledTimes(expected);
  });
  test('should only call handler for specified keyCode', function () {
    var keyCode = 13;
    var handler = jest.fn();
    var callback = (0, _handle.handle)((0, _handle.forKeyCode)(keyCode), handler);
    callback(makeEvent());
    expect(handler).not.toHaveBeenCalled();
    callback(makeEvent({
      keyCode: keyCode
    }));
    expect(handler).toHaveBeenCalled();
  });
  test('should only call handler for specified event prop', function () {
    var handler = jest.fn();
    var prop = 'index';
    var value = 0;
    var callback = (0, _handle.handle)((0, _handle.forEventProp)(prop, value), handler); // undefined shouldn't pass

    callback(makeEvent());
    expect(handler).not.toHaveBeenCalled(); // == check shouldn't pass

    callback(makeEvent(_defineProperty({}, prop, false)));
    expect(handler).not.toHaveBeenCalled(); // === should pass

    callback(makeEvent(_defineProperty({}, prop, value)));
    expect(handler).toHaveBeenCalled();
  });
  test('should only call handler for specified prop', function () {
    var handler = jest.fn();
    var callback = (0, _handle.handle)((0, _handle.forProp)('checked', true), handler); // undefined shouldn't pass

    callback({}, {});
    expect(handler).not.toHaveBeenCalled(); // == check shouldn't pass

    callback({}, {
      checked: 1
    });
    expect(handler).not.toHaveBeenCalled(); // === should pass

    callback({}, {
      checked: true
    });
    expect(handler).toHaveBeenCalled();
  });
  test('should forward events to function specified in provided props', function () {
    var event = 'onMyClick';
    var prop = 'index';
    var propValue = 0;
    var spy = jest.fn();

    var props = _defineProperty({}, event, spy);

    var payload = _defineProperty({}, prop, propValue);

    (0, _handle.handle)((0, _handle.forward)(event))(payload, props);
    var expected = true;
    var actual = spy.mock.calls[0][0][prop] === propValue;
    expect(actual).toBe(expected);
  });
  test('should forwardWithPrevent events to function specified in provided props when preventDefault() hasn\'t been called', function () {
    var event = 'onMyClick';
    var handler = jest.fn();
    var callback = (0, _handle.handle)((0, _handle.forwardWithPrevent)(event), handler);
    callback();
    expect(handler).toHaveBeenCalledTimes(1);
  });
  test('should not forwardWithPrevent events to function specified in provided props when preventDefault() has been called', function () {
    var event = 'onMyClick';
    var handler = jest.fn();
    var callback = (0, _handle.handle)((0, _handle.forwardWithPrevent)(event), handler); // should stop chain when `preventDefault()` has been called

    callback({}, {
      'onMyClick': function onMyClick(ev) {
        return ev.preventDefault();
      }
    });
    expect(handler).not.toHaveBeenCalled();
  });
  test('should include object props as second arg when bound', function () {
    var componentInstance = {
      context: {},
      props: {
        value: 1
      }
    };
    var handler = jest.fn();

    var h = _handle.handle.bind(componentInstance);

    var callback = h(handler);
    callback();
    var expected = 1;
    var actual = handler.mock.calls[0][1].value;
    expect(actual).toBe(expected);
  });
  test('should include object context as third arg when bound', function () {
    var componentInstance = {
      context: {
        value: 1
      },
      props: {}
    };
    var handler = jest.fn();

    var h = _handle.handle.bind(componentInstance);

    var callback = h(handler);
    callback();
    var expected = 1;
    var actual = handler.mock.calls[0][2].value;
    expect(actual).toBe(expected);
  });
  describe('finally', function () {
    test('should call the finally callback when handle returns true', function () {
      var finallyCallback = jest.fn();
      var callback = (0, _handle.handle)(returnsTrue)["finally"](finallyCallback);
      callback(makeEvent());
      var expected = 1;
      expect(finallyCallback).toHaveBeenCalledTimes(expected);
    });
    test('should call the finally callback when handle returns false', function () {
      var finallyCallback = jest.fn();
      var callback = (0, _handle.handle)(returnsFalse)["finally"](finallyCallback);
      callback(makeEvent());
      var expected = 1;
      expect(finallyCallback).toHaveBeenCalledTimes(expected);
    });
    test('should call the finally callback when handle throws an error', function () {
      var finallyCallback = jest.fn();
      var callback = (0, _handle.handle)(function () {
        throw new Error('Something has gone awry ...');
      })["finally"](finallyCallback);

      try {
        callback(makeEvent());
      } catch (e) {// we don't want the error to interrupt the test
      }

      var expected = 1;
      expect(finallyCallback).toHaveBeenCalledTimes(expected);
    });
  });
  describe('#oneOf', function () {
    test('should call each handler until one passes', function () {
      var handler = jest.fn(returnsTrue);
      var h1 = [returnsFalse, handler];
      var h2 = [returnsTrue, handler];
      var callback = (0, _handle.oneOf)(h1, h1, h2);
      callback();
      var expected = 1;
      expect(handler).toHaveBeenCalledTimes(expected);
    });
    test('should stop if the first handler passes', function () {
      var handler = jest.fn(returnsTrue);
      var callback = (0, _handle.oneOf)([returnsTrue, handler], [returnsTrue, handler], [returnsTrue, handler]);
      callback();
      var expected = 1;
      expect(handler).toHaveBeenCalledTimes(expected);
    });
    test('should pass args to condition', function () {
      var handler = jest.fn(returnsTrue);
      var callback = (0, _handle.oneOf)([handler, returnsTrue]);
      var ev = {
        value: 1
      };
      callback(ev);
      var expected = ev;
      var actual = handler.mock.calls[0][0];
      expect(actual).toBe(expected);
    });
    test('should pass args to handlers', function () {
      var handler = jest.fn(returnsTrue);
      var callback = (0, _handle.oneOf)([returnsTrue, handler]);
      var ev = {
        value: 1
      };
      callback(ev);
      var expected = ev;
      var actual = handler.mock.calls[0][0];
      expect(actual).toBe(expected);
    });
    test('should return true when the passed condition branch returns a truthy value', function () {
      var callback = (0, _handle.oneOf)([returnsTrue, function () {
        return 'ok';
      }]);
      var expected = true;
      var actual = callback();
      expect(actual).toBe(expected);
    });
    test('should return false when the passed condition branch returns a falsy value', function () {
      var callback = (0, _handle.oneOf)([returnsTrue, function () {
        return null;
      }]);
      var expected = false;
      var actual = callback();
      expect(actual).toBe(expected);
    });
    test('should return false when no conditions pass', function () {
      var callback = (0, _handle.oneOf)([returnsFalse, returnsTrue], [returnsFalse, returnsTrue]);
      var expected = false;
      var actual = callback();
      expect(actual).toBe(expected);
    });
    test('should support bound handlers', function () {
      var componentInstance = {
        props: {},
        context: {
          value: 1
        }
      };
      var handler = jest.fn();

      var h = _handle.handle.bind(componentInstance);

      var callback = (0, _handle.oneOf)([returnsTrue, h(handler)]);
      callback();
      var expected = 1;
      var actual = handler.mock.calls[0][2].value;
      expect(actual).toBe(expected);
    });
    test('should include object props as second arg when bound', function () {
      var componentInstance = {
        props: {
          value: 1
        },
        context: {}
      };
      var handler = jest.fn();

      var o = _handle.oneOf.bind(componentInstance);

      var callback = o([returnsTrue, handler]);
      callback();
      var expected = 1;
      var actual = handler.mock.calls[0][1].value;
      expect(actual).toBe(expected);
    });
    test('should include object context as third arg when bound', function () {
      var componentInstance = {
        props: {},
        context: {
          value: 1
        }
      };
      var handler = jest.fn();

      var o = _handle.oneOf.bind(componentInstance);

      var callback = o([returnsTrue, handler]);
      callback();
      var expected = 1;
      var actual = handler.mock.calls[0][2].value;
      expect(actual).toBe(expected);
    });
    test('should support finally callback', function () {
      var handler = jest.fn();
      var callback = (0, _handle.oneOf)([returnsFalse, returnsTrue], [returnsFalse, returnsTrue])["finally"](handler);
      callback();
      var expected = 1;
      expect(handler).toHaveBeenCalledTimes(expected);
    });
  });
  describe('#adaptEvent', function () {
    test('should pass the adapted event payload to the provided handler', function () {
      var handler = jest.fn();

      var onlyValue = function onlyValue(_ref) {
        var value = _ref.value;
        return {
          value: value
        };
      };

      var ev = {
        value: 1,
        message: 'ok'
      };
      (0, _handle.adaptEvent)(onlyValue, handler)(ev);
      var expected = {
        value: 1
      };
      var actual = handler.mock.calls[0][0];
      expect(actual).toEqual(expected);
    });
    test('should pass additional arguments to the provided handler', function () {
      var handler = jest.fn();

      var returnOne = function returnOne() {
        return 1;
      };

      (0, _handle.adaptEvent)(returnOne, handler)(0, 2, 3);
      var expected = [1, 2, 3];
      var actual = handler.mock.calls[0];
      expect(actual).toEqual(expected);
    });
    test('should support bound adapter function', function () {
      var obj = {
        adapt: function adapt() {
          return 1;
        }
      };
      var handler = jest.fn();
      var fn = (0, _handle.adaptEvent)((0, _handle.call)('adapt'), handler).bind(obj);
      fn(0, 2, 3);
      var expected = [1, 2, 3];
      var actual = handler.mock.calls[0];
      expect(actual).toEqual(expected);
    });
    test('should support bound handler function', function () {
      var obj = {
        handler: jest.fn()
      };

      var returnOne = function returnOne() {
        return 1;
      };

      var fn = (0, _handle.adaptEvent)(returnOne, (0, _handle.call)('handler')).bind(obj);
      fn(0, 2, 3);
      var expected = [1, 2, 3];
      var actual = obj.handler.mock.calls[0];
      expect(actual).toEqual(expected);
    });
  });
  describe('#forwardCustom', function () {
    test('should pass an object with `type` when no adapter is provided', function () {
      var handler = jest.fn();
      (0, _handle.forwardCustom)('onCustomEvent')(null, {
        onCustomEvent: handler
      });
      var expected = {
        type: 'onCustomEvent'
      };
      var actual = handler.mock.calls[0][0];
      expect(actual).toEqual(expected);
    });
    test('should add `type` to object returned by adapter', function () {
      var handler = jest.fn();

      var adapter = function adapter() {
        return {
          index: 0
        };
      };

      (0, _handle.forwardCustom)('onCustomEvent', adapter)(null, {
        onCustomEvent: handler
      });
      var expected = {
        type: 'onCustomEvent',
        index: 0
      };
      var actual = handler.mock.calls[0][0];
      expect(actual).toEqual(expected);
    });
    test('should create an event payload if the adapter returns nothing', function () {
      var handler = jest.fn();

      var adapter = function adapter() {
        return null;
      };

      (0, _handle.forwardCustom)('onCustomEvent', adapter)(null, {
        onCustomEvent: handler
      });
      var expected = {
        type: 'onCustomEvent'
      };
      var actual = handler.mock.calls[0][0];
      expect(actual).toEqual(expected);
    });
    test('should pass event, props, and context args to adapter', function () {
      var adapter = jest.fn();
      var args = [1, // ev,
      2, // props,
      3 // context
      ];
      (0, _handle.forwardCustom)('onCustomEvent', adapter).apply(void 0, args);
      var expected = args;
      var actual = adapter.mock.calls[0];
      expect(actual).toEqual(expected);
    });
  });
});