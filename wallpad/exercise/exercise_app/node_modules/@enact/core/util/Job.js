"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.Job = void 0;

var _invariant = _interopRequireDefault(require("invariant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * Provides a convenient way to manage timed execution of functions.
 *
 * @class Job
 * @memberof core/util
 * @public
 */
var Job = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Function}    fn       Function to execute as the requested job.
   * @param {Number}      timeout  The number of milliseconds to wait before starting the job.
   *
   * @memberof core/util.Job.prototype
   */
  function Job(fn, _timeout) {
    var _this = this;

    _classCallCheck(this, Job);

    this.id = null;
    this.fn = null;
    this.timeout = null;
    this.type = null;

    this.start = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this.startAfter.apply(_this, [_this.timeout].concat(args));
    };

    this.startAfter = function (timeout) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      _this.stop();

      _this.type = 'timeout';
      _this.id = setTimeout(function () {
        return _this.run(args);
      }, timeout);
    };

    this.stop = function () {
      if (_this.id) {
        if (_this.type === 'idle') {
          window.cancelIdleCallback(_this.id);
        } else if (_this.type === 'raf') {
          window.cancelAnimationFrame(_this.id);
        } else if (_this.type === 'timeout') {
          clearTimeout(_this.id);
        }

        _this.id = _this.type = null;
      }
    };

    this.throttle = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      _this.throttleUntil.apply(_this, [_this.timeout].concat(args));
    };

    this.throttleUntil = function (timeout) {
      if (!_this.id) {
        _this.type = 'timeout';

        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        _this.run(args);

        _this.id = setTimeout(_this.stop, timeout);
      }
    };

    this.idle = function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      _this.idleUntil.apply(_this, [null].concat(args));
    };

    this.idleUntil = function (timeout) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        args[_key6 - 1] = arguments[_key6];
      }

      if (typeof window !== 'undefined' && window.requestIdleCallback) {
        _this.stop();

        _this.type = 'idle';
        _this.id = window.requestIdleCallback(function () {
          return _this.run(args);
        }, {
          timeout: timeout
        });
      } else {
        // since we can't request an idle callback, just pass to startAfter()
        _this.startAfter.apply(_this, [timeout].concat(args));
      }
    };

    this.startRaf = function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      _this.startRafAfter.apply(_this, [_this.timeout].concat(args));
    };

    this.startRafAfter = function (timeout) {
      for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
        args[_key8 - 1] = arguments[_key8];
      }

      _this.type = 'raf';

      if (typeof window !== 'undefined') {
        var time = null;

        var callback = function callback(timestamp) {
          if (time === null) {
            time = timestamp;
          }

          if (timeout && timestamp - time < timeout) {
            _this.id = window.requestAnimationFrame(callback);
          } else {
            time = null;

            _this.run(args);

            window.cancelAnimationFrame(_this.id);
            _this.id = null;
          }
        };

        _this.id = window.requestAnimationFrame(callback);
      } else {
        // If requestAnimationFrame is not supported just run the function immediately
        _this.run(args);
      }
    };

    this.promise = function (promise) {
      !(promise && typeof promise.then === 'function') ? process.env.NODE_ENV !== "production" ? (0, _invariant["default"])(false, 'promise expects a thenable') : (0, _invariant["default"])(false) : void 0;
      _this.type = 'promise';
      _this.id = promise;
      return promise.then(function (result) {
        if (_this.id === promise) {
          _this.stop();

          return _this.run([result]);
        }
      });
    };

    this.fn = fn;
    this.timeout = _timeout;
  }

  _createClass(Job, [{
    key: "run",
    value: function run(args) {
      // don't want to inadvertently apply Job's context on `fn`
      return this.fn.apply(null, args);
    }
    /**
     * Starts the job.
     *
     * @method
     * @param   {...*}       [args]  Any args passed are forwarded to the callback
     *
     * @returns {undefined}
     * @memberof core/util.Job.prototype
     * @public
     */

  }]);

  return Job;
}();

exports.Job = Job;
var _default = Job;
exports["default"] = _default;