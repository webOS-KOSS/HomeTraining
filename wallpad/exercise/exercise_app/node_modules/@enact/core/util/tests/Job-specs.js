"use strict";

var _react = require("@testing-library/react");

var _Job = _interopRequireDefault(require("../Job"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

describe('Job', function () {
  beforeEach(function () {
    jest.useFakeTimers();
  });
  afterEach(function () {
    jest.useRealTimers();
  });
  describe('#start', function () {
    test('should start job', function (done) {
      var j = new _Job["default"](done, 10);
      j.start();
      jest.runAllTimers();
    });
    test('should pass args to fn', function (done) {
      var value = 'argument';

      var fn = function fn(arg) {
        if (arg === value) {
          done();
        } else {
          done(new Error('fn did not receive argument'));
        }
      };

      var j = new _Job["default"](fn, 10);
      j.start(value);
      jest.runAllTimers();
    });
  });
  describe('#stop', function () {
    test('should stop job', function (done) {
      var ran = false;
      var j = new _Job["default"](function () {
        ran = true;
        done(new Error('job wasn\'t stopped'));
      }, 10);
      j.start();
      j.stop();
      (0, _react.act)(function () {
        return jest.advanceTimersByTime(30);
      });
      if (!ran) done();
    });
  });
  describe('#throttle', function () {
    test('should throttle job', function (done) {
      var number = 0;
      var j = new _Job["default"](function () {
        number++;
      }, 20);
      j.throttle();
      (0, _react.act)(function () {
        return jest.advanceTimersByTime(5);
      });
      j.throttle();
      (0, _react.act)(function () {
        return jest.advanceTimersByTime(10);
      });
      j.throttle();
      (0, _react.act)(function () {
        return jest.advanceTimersByTime(10);
      });
      j.throttle();
      (0, _react.act)(function () {
        return jest.advanceTimersByTime(5);
      });

      if (number === 2) {
        done();
      } else {
        done(new Error('too many or too few calls' + number));
      }
    });
    test('should pass args to fn', function (done) {
      var value = 'argument';

      var fn = function fn(arg) {
        if (arg === value) {
          done();
        } else {
          done(new Error('fn did not receive argument'));
        }
      };

      var j = new _Job["default"](fn, 10);
      j.throttle(value);
    });
  });
  describe('#idle', function () {
    // polyfill for PhantomJS to verify expected idle behavior as much as possible
    var windowRequest = window.requestIdleCallback;
    var windowCancel = window.cancelIdleCallback;
    beforeAll(function () {
      window.requestIdleCallback = windowRequest || function (fn) {
        return setTimeout(fn, 0);
      };

      window.cancelIdleCallback = windowCancel || function (id) {
        clearTimeout(id);
      };
    });
    afterAll(function () {
      window.requestIdleCallback = windowRequest;
      window.cancelIdleCallback = windowCancel;
    });
    test('should start job', function (done) {
      var j = new _Job["default"](done, 10);
      j.idle();
      jest.runAllTimers();
    });
    test('should pass args to fn', function (done) {
      var value = 'argument';

      var fn = function fn(arg) {
        if (arg === value) {
          done();
        } else {
          done(new Error('fn did not receive argument'));
        }
      };

      var j = new _Job["default"](fn, 10);
      j.idle(value);
      jest.runAllTimers();
    });
    test('should clear an existing job id before starting job', function (done) {
      var fn = function fn(arg) {
        if (arg === 'first') {
          done(new Error('First job ran'));
        } else {
          done();
        }
      };

      var j = new _Job["default"](fn);
      j.idle('first');
      j.idle('second');
      jest.runAllTimers();
    });
  });
  describe('#promise', function () {
    test('should throw when passed a non-thenable argument', function (done) {
      var j = new _Job["default"](function () {
        return done(new Error('Unexpected job execution'));
      });

      try {
        j.promise({});
      } catch (msg) {
        done();
      }
    });
    test('should support a non-Promise, thenable argument', function (done) {
      var j = new _Job["default"](function () {
        return done();
      });

      try {
        j.promise({
          then: function then(fn) {
            return fn(true);
          }
        });
      } catch (msg) {
        done(msg);
      }
    });
    test('should start job for a resolved promise', function (done) {
      var j = new _Job["default"](function () {
        return done();
      });
      j.promise(Promise.resolve(true));
    });
    test('should not start job for a rejected promise', function (done) {
      var j = new _Job["default"](function () {
        done(new Error('Job ran for rejected promise'));
      });
      j.promise(Promise.reject(true))["catch"](function () {});
      (0, _react.act)(function () {
        return jest.advanceTimersByTime(10);
      });
      done();
    });
    test('should not start job when stopped before promise resolves', function (done) {
      var j = new _Job["default"](function () {
        done(new Error('Job ran for stopped promise'));
      });
      j.promise(new Promise(function (resolve) {
        return setTimeout(resolve, 20);
      }));
      (0, _react.act)(function () {
        return jest.advanceTimersByTime(10);
      });
      j.stop();
      (0, _react.act)(function () {
        return jest.advanceTimersByTime(20);
      });
      done();
    });
    test('should not start job when another is started', function (done) {
      var j = new _Job["default"](function (value) {
        expect(value).toBe(2);
        done();
      });
      j.promise(new Promise(function (resolve) {
        return resolve(1);
      }));
      j.promise(new Promise(function (resolve) {
        return resolve(2);
      }));
    });
    test('should return the value from the job to the resolved promise', function (done) {
      var j = new _Job["default"](function () {
        return 'job value';
      });
      j.promise(Promise.resolve(true)).then(function (value) {
        expect(value).toBe('job value');
        done();
      });
    });
    test('should not return the value from the job to the replaced promise', function (done) {
      var j = new _Job["default"](function () {
        return 'job value';
      });
      j.promise(Promise.resolve(true)).then(function (value) {
        expect(value).toBeUndefined();
      });
      j.promise(Promise.resolve(true)).then(function () {
        return done();
      });
    });
  });
});