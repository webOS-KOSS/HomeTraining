"use strict";

var _react = require("react");

var _util = require("../util");

describe('util', function () {
  describe('isRenderable', function () {
    test('should return {true} for function', function () {
      var expected = true;
      var view = (0, _util.isRenderable)(function () {});
      expect(view).toEqual(expected);
    });
    test('should return {true} for string', function () {
      var expected = true;
      var view = (0, _util.isRenderable)('div');
      expect(view).toEqual(expected);
    });
    test('should return {true} for React.forwardRef', function () {
      var expected = true;
      var view = (0, _util.isRenderable)( /*#__PURE__*/(0, _react.forwardRef)(function () {}));
      expect(view).toEqual(expected);
    });
    test('should return {true} for React.memo', function () {
      var expected = true;
      var view = (0, _util.isRenderable)( /*#__PURE__*/(0, _react.memo)(function () {}));
      expect(view).toEqual(expected);
    });
    test('should return {true} for React.lazy', function () {
      var expected = true;
      var view = (0, _util.isRenderable)( /*#__PURE__*/(0, _react.lazy)(function () {}));
      expect(view).toEqual(expected);
    });
  });
  describe('memoize', function () {
    test('should memoize function', function () {
      var obj = {},
          testMethod = function testMethod(key) {
        obj[key] = (obj[key] || 0) + 1;
      },
          memoizedTest = (0, _util.memoize)(testMethod);

      expect(obj).not.toHaveProperty('a');
      memoizedTest('a');
      expect(obj).toHaveProperty('a', 1);
      memoizedTest('a');
      memoizedTest('a');
      expect(obj).toHaveProperty('a', 1);
    });
    test('should forward all args to memoized function', function () {
      var spy = jest.fn();
      var memoized = (0, _util.memoize)(spy);
      memoized(1, 2);
      var expected = [1, 2];
      var actual = spy.mock.calls[0];
      expect(expected).toEqual(actual);
    });
  });
  describe('mapAndFilterChildren', function () {
    test('Returns null if null passed', function () {
      var expected = null;
      var actual = (0, _util.mapAndFilterChildren)(null, function (val) {
        return val;
      });
      expect(actual).toBe(expected);
    });
    test('Returns passed array if identity filter', function () {
      var children = [1, 2, 3];
      var expected = children;
      var actual = (0, _util.mapAndFilterChildren)(children, function (val) {
        return val;
      });
      expect(actual).toEqual(expected);
    });
    test('Returns passed array without nullish or false entries with identity filter', function () {
      // eslint-disable-next-line no-undefined
      var children = [1, 2, null, 3, undefined, false];
      var expected = [1, 2, 3];
      var actual = (0, _util.mapAndFilterChildren)(children, function (val) {
        return val;
      });
      expect(actual).toEqual(expected);
    });
    test('Does not call filter with nullish or false entries', function () {
      var spy = jest.fn(); // eslint-disable-next-line no-undefined

      var children = [1, 2, null, 3, undefined, false];
      (0, _util.mapAndFilterChildren)(children, spy);
      var expected = 3;
      var actual = spy.mock.calls.length;
      expect(actual).toBe(expected);
    });
    test('Returns without null entries from filter', function () {
      var children = [1, 2, 3];
      var expected = [1, 3];
      var actual = (0, _util.mapAndFilterChildren)(children, function (val) {
        return val === 2 ? null : val;
      });
      expect(actual).toEqual(expected);
    });
    test('Runs custom filter', function () {
      var children = [1, 2, 3];
      var expected = [1];
      var actual = (0, _util.mapAndFilterChildren)(children, function (val) {
        return val === 2 ? null : val;
      }, function (val) {
        return val === 1;
      });
      expect(actual).toEqual(expected);
    });
    test('should forward value and index to callback', function () {
      var spy = jest.fn();
      (0, _util.mapAndFilterChildren)([1], spy);
      var expected = [1, // value
      0 // index
      ];
      var actual = spy.mock.calls[0];
      expect(expected).toEqual(actual);
    });
  });
});