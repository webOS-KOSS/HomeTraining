"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _util = require("@enact/core/util");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var refs = {};

var adjustPath = function adjustPath(path) {
  if (!/^(luna|palm):\/\//.test(path)) path = 'luna://' + path;
  if (path.slice(-1) !== '/') path += '/';
  return path;
}; // default handlers


var failureHandler = function failureHandler(_ref) {
  var errorText = _ref.errorText;
  return console.error("LS2Request: ".concat(errorText));
};

var timeoutHandler = function timeoutHandler(_ref2) {
  var errorText = _ref2.errorText;
  return console.warn("LS2Request: ".concat(errorText));
};
/**
 * A class for managing LS2 Requests.
 *
 * @memberof webos/LS2Request
 * @class
 */


var LS2Request = /*#__PURE__*/function () {
  /**
   * Create a new LS2 request
   *
   * @memberof webos/LS2Request.LS2Request
   * @constructor
   */
  function LS2Request() {
    var _this = this;

    _classCallCheck(this, LS2Request);

    this.timeoutJob = new _util.Job(function (_ref3) {
      var onTimeout = _ref3.onTimeout,
          timeout = _ref3.timeout;
      onTimeout({
        errorCode: -2,
        errorText: "Request timed out after ".concat(timeout, " ms."),
        returnValue: false
      }); // cancel the request

      _this.cancel();
    });
    this.bridge = null;
    this.subscribe = false;
  }
  /**
   * Send a request to an LS2 service method.
   *
   * @method
   * @memberof webos/LS2Request.LS2Request.prototype
   * @param {Object} options Options for the LS2 Request call
   * @param {String} options.service The name of the LS2 service.
   * @param {String} options.method The name of the method.
   * @param {Object} options.parameters Any parameters required by the service method.
   * @param {Function} options.onSuccess The success handler for the request.
   * @param {Function} options.onFailure The failure handler for the request.
   * @param {Function} options.onComplete The handler to run when the request
   *	is completed, regardless of return status.
   * @param {Function} options.onTimeout The handler to run when the request
   *	times out.  Used in conjunction with `timeout`.
   * @param {Boolean} options.subscribe Subscribe to service methods that support subscription.
   * @param {Number} options.timeout The delay in milliseconds to wait for the request to return.
   * @returns {webos/LS2Request}
   * @public
   */


  _createClass(LS2Request, [{
    key: "send",
    value: function send(_ref4) {
      var _ref4$service = _ref4.service,
          service = _ref4$service === void 0 ? '' : _ref4$service,
          _ref4$method = _ref4.method,
          method = _ref4$method === void 0 ? '' : _ref4$method,
          _ref4$parameters = _ref4.parameters,
          parameters = _ref4$parameters === void 0 ? {} : _ref4$parameters,
          _ref4$onSuccess = _ref4.onSuccess,
          onSuccess = _ref4$onSuccess === void 0 ? null : _ref4$onSuccess,
          _ref4$onFailure = _ref4.onFailure,
          onFailure = _ref4$onFailure === void 0 ? null : _ref4$onFailure,
          _ref4$onComplete = _ref4.onComplete,
          onComplete = _ref4$onComplete === void 0 ? null : _ref4$onComplete,
          _ref4$onTimeout = _ref4.onTimeout,
          onTimeout = _ref4$onTimeout === void 0 ? timeoutHandler : _ref4$onTimeout,
          _ref4$subscribe = _ref4.subscribe,
          subscribe = _ref4$subscribe === void 0 ? false : _ref4$subscribe,
          _ref4$timeout = _ref4.timeout,
          timeout = _ref4$timeout === void 0 ? 0 : _ref4$timeout;
      this.cancelled = false;

      if (!onFailure && !onComplete) {
        onFailure = failureHandler;
      }

      if (typeof window !== 'object' || !window.PalmServiceBridge) {
        /* eslint no-unused-expressions: ["error", { "allowShortCircuit": true }]*/
        if (onFailure) onFailure({
          errorCode: -1,
          errorText: 'PalmServiceBridge not found.',
          returnValue: false
        });
        if (onComplete) onComplete({
          errorCode: -1,
          errorText: 'PalmServiceBridge not found.',
          returnValue: false
        });
        console.error('PalmServiceBridge not found.');
        return;
      }

      if (this.ts && refs[this.ts]) {
        delete refs[this.ts];
      }

      this.subscribe = subscribe;

      if (this.subscribe) {
        parameters.subscribe = this.subscribe;
      }

      if (parameters.subscribe) {
        this.subscribe = parameters.subscribe;
      }

      this.ts = performance.now();
      refs[this.ts] = this; // eslint-disable-next-line no-undef

      this.bridge = new PalmServiceBridge();
      this.bridge.onservicecallback = this.callback.bind(this, onSuccess, onFailure, onComplete);

      if (timeout) {
        this.timeoutJob.startAfter(timeout, {
          onTimeout: onTimeout,
          timeout: timeout
        });
      }

      this.bridge.call(adjustPath(service) + method, JSON.stringify(parameters));
      return this;
    }
  }, {
    key: "callback",
    value: function callback(onSuccess, onFailure, onComplete, msg) {
      if (this.cancelled) {
        return;
      } // remove timeout job


      this.timeoutJob.stop();
      var parsedMsg;

      if (msg == null) {
        parsedMsg = {
          errorCode: -1,
          errorText: "Invalid response: ".concat(msg),
          returnValue: false
        };
      } else {
        try {
          parsedMsg = JSON.parse(msg);
        } catch (e) {
          parsedMsg = {
            errorCode: -1,
            errorText: msg,
            returnValue: false
          };
        }
      }

      if (parsedMsg.errorCode || parsedMsg.returnValue === false) {
        if (onFailure) {
          onFailure(parsedMsg);
        }
      } else if (onSuccess) {
        onSuccess(parsedMsg);
      }

      if (onComplete) {
        onComplete(parsedMsg);
      }

      if (!this.subscribe) {
        this.cancel();
      }
    }
    /**
     * Cancel the current LS2 request.
     *
     * @method
     * @memberof webos/LS2Request.LS2Request.prototype
     * @returns {undefined}
     * @public
     */

  }, {
    key: "cancel",
    value: function cancel() {
      // remove timeout job
      this.timeoutJob.stop();
      this.cancelled = true;

      if (this.bridge) {
        this.bridge.cancel();
        this.bridge = null;
      }

      if (this.ts && refs[this.ts]) {
        delete refs[this.ts];
      }
    }
  }]);

  return LS2Request;
}();

exports["default"] = LS2Request;