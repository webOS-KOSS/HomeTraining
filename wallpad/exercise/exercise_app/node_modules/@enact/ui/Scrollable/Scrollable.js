"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.constants = exports.ScrollableBase = exports.Scrollable = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _handle = _interopRequireWildcard(require("@enact/core/handle"));

var _keymap = require("@enact/core/keymap");

var _Registry = _interopRequireDefault(require("@enact/core/internal/Registry"));

var _util = require("@enact/core/util");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _clamp = _interopRequireDefault(require("ramda/src/clamp"));

var _react = require("react");

var _ForwardRef = _interopRequireDefault(require("../ForwardRef"));

var _Resizable = require("../Resizable");

var _resolution = _interopRequireDefault(require("../resolution"));

var _Touchable = _interopRequireDefault(require("../Touchable"));

var _ScrollAnimator = _interopRequireDefault(require("./ScrollAnimator"));

var _Scrollbar = _interopRequireDefault(require("./Scrollbar"));

var _ScrollableModule = _interopRequireDefault(require("./Scrollable.module.css"));

var _jsxRuntime = require("react/jsx-runtime");

var _excluded = ["className", "containerRenderer", "noScrollByDrag", "rtl", "style"],
    _excluded2 = ["childRenderer"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var constants = {
  animationDuration: 1000,
  epsilon: 1,
  flickConfig: {
    maxDuration: null
  },
  isPageDown: (0, _keymap.is)('pageDown'),
  isPageUp: (0, _keymap.is)('pageUp'),
  nop: function nop() {},
  overscrollTypeNone: 0,
  overscrollTypeHold: 1,
  overscrollTypeOnce: 2,
  overscrollTypeDone: 9,
  paginationPageMultiplier: 0.66,
  scrollStopWaiting: 200,
  scrollWheelPageMultiplierForMaxPixel: 0.2 // The ratio of the maximum distance scrolled by wheel to the size of the viewport.

},
    animationDuration = constants.animationDuration,
    epsilon = constants.epsilon,
    flickConfig = constants.flickConfig,
    isPageDown = constants.isPageDown,
    isPageUp = constants.isPageUp,
    nop = constants.nop,
    overscrollTypeDone = constants.overscrollTypeDone,
    overscrollTypeHold = constants.overscrollTypeHold,
    overscrollTypeNone = constants.overscrollTypeNone,
    overscrollTypeOnce = constants.overscrollTypeOnce,
    paginationPageMultiplier = constants.paginationPageMultiplier,
    scrollStopWaiting = constants.scrollStopWaiting,
    scrollWheelPageMultiplierForMaxPixel = constants.scrollWheelPageMultiplierForMaxPixel;
exports.constants = constants;
var TouchableDiv = (0, _ForwardRef["default"])({
  prop: 'ref'
}, (0, _Touchable["default"])('div'));
/**
 * An unstyled component that passes scrollable behavior information as its render prop's arguments.
 *
 * @class ScrollableBase
 * @memberof ui/Scrollable
 * @ui
 * @private
 */

var ScrollableBase = /*#__PURE__*/function (_Component) {
  _inherits(ScrollableBase, _Component);

  var _super = _createSuper(ScrollableBase);

  function ScrollableBase(props) {
    var _this;

    _classCallCheck(this, ScrollableBase);

    _this = _super.call(this, props);

    _this.handleResizeWindow = function () {
      // `handleSize` in `ui/resolution.ResolutionDecorator` should be executed first.
      setTimeout(function () {
        var handleResizeWindow = _this.props.handleResizeWindow;

        if (handleResizeWindow) {
          handleResizeWindow();
        }

        _this.scrollTo({
          position: {
            x: 0,
            y: 0
          },
          animate: false
        });

        _this.enqueueForceUpdate();
      });
    };

    _this.pixelPerLine = 39;
    _this.scrollWheelMultiplierForDeltaPixel = 1.5;
    _this.deferScrollTo = true;
    _this.isScrollAnimationTargetAccumulated = false;
    _this.isUpdatedScrollThumb = false;
    _this.lastInputType = null;
    _this.overscrollEnabled = false;
    _this.overscrollStatus = {
      horizontal: {
        before: {
          type: overscrollTypeNone,
          ratio: 0
        },
        after: {
          type: overscrollTypeNone,
          ratio: 0
        }
      },
      vertical: {
        before: {
          type: overscrollTypeNone,
          ratio: 0
        },
        after: {
          type: overscrollTypeNone,
          ratio: 0
        }
      }
    };
    _this.bounds = {
      clientWidth: 0,
      clientHeight: 0,
      scrollWidth: 0,
      scrollHeight: 0,
      maxTop: 0,
      maxLeft: 0
    };
    _this.wheelDirection = 0;
    _this.isDragging = false;
    _this.scrolling = false;
    _this.scrollLeft = 0;
    _this.scrollTop = 0;
    _this.scrollToInfo = null;
    _this.childRefCurrent = null;
    _this.animator = new _ScrollAnimator["default"]();

    _this.getRtlX = function (x) {
      return _this.props.rtl ? -x : x;
    };

    _this.onMouseDown = (0, _handle["default"])((0, _handle.forwardWithPrevent)('onMouseDown'), _this.stop).bindAs(_assertThisInitialized(_this), 'onMouseDown');

    _this.onDragStart = function (ev) {
      if (ev.type === 'dragstart') return;
      (0, _handle.forward)('onDragStart', ev, _this.props);

      _this.stop();

      _this.isDragging = true;
      _this.dragStartX = _this.scrollLeft + _this.getRtlX(ev.x);
      _this.dragStartY = _this.scrollTop + ev.y;
    };

    _this.onDrag = function (ev) {
      if (ev.type === 'drag') return;
      var direction = _this.props.direction;
      _this.lastInputType = 'drag';
      (0, _handle.forward)('onDrag', ev, _this.props);

      _this.start({
        targetX: direction === 'vertical' ? 0 : _this.dragStartX - _this.getRtlX(ev.x),
        // 'horizontal' or 'both'
        targetY: direction === 'horizontal' ? 0 : _this.dragStartY - ev.y,
        // 'vertical' or 'both'
        animate: false,
        overscrollEffect: _this.props.overscrollEffectOn.drag
      });
    };

    _this.onDragEnd = function (ev) {
      if (ev.type === 'dragend') return;
      _this.isDragging = false;
      (0, _handle.forward)('onDragEnd', ev, _this.props);

      if (_this.flickTarget) {
        var _this$flickTarget = _this.flickTarget,
            targetX = _this$flickTarget.targetX,
            targetY = _this$flickTarget.targetY,
            duration = _this$flickTarget.duration;
        _this.lastInputType = 'drag';
        _this.isScrollAnimationTargetAccumulated = false;

        _this.start({
          targetX: targetX,
          targetY: targetY,
          duration: duration,
          overscrollEffect: _this.props.overscrollEffectOn.drag
        });
      } else {
        _this.stop();
      }

      if (_this.overscrollEnabled) {
        // not check this.props.overscrollEffectOn.drag for safety
        _this.clearAllOverscrollEffects();
      }

      _this.flickTarget = null;
    };

    _this.onFlick = function (ev) {
      var direction = _this.props.direction;
      _this.flickTarget = _this.animator.simulate(_this.scrollLeft, _this.scrollTop, direction !== 'vertical' ? _this.getRtlX(-ev.velocityX) : 0, direction !== 'horizontal' ? -ev.velocityY : 0);

      if (_this.props.onFlick) {
        (0, _handle.forward)('onFlick', ev, _this.props);
      }
    };

    _this.onWheel = function (ev) {
      if (_this.isDragging) {
        ev.preventDefault();
        ev.stopPropagation();
      } else {
        var _assertThisInitialize = _assertThisInitialized(_this),
            verticalScrollbarRef = _assertThisInitialize.verticalScrollbarRef,
            horizontalScrollbarRef = _assertThisInitialize.horizontalScrollbarRef,
            bounds = _this.getScrollBounds(),
            canScrollHorizontally = _this.canScrollHorizontally(bounds),
            canScrollVertically = _this.canScrollVertically(bounds),
            eventDeltaMode = ev.deltaMode,
            eventDelta = -ev.wheelDeltaY || ev.deltaY;

        var delta = 0,
            direction;
        _this.lastInputType = 'wheel';

        if (_this.props.noScrollByWheel) {
          return;
        }

        if (canScrollVertically) {
          delta = _this.calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientHeight * scrollWheelPageMultiplierForMaxPixel);
        } else if (canScrollHorizontally) {
          delta = _this.calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientWidth * scrollWheelPageMultiplierForMaxPixel);
        }

        direction = Math.sign(delta);

        if (direction !== _this.wheelDirection) {
          _this.isScrollAnimationTargetAccumulated = false;
          _this.wheelDirection = direction;
        }

        (0, _handle.forward)('onWheel', {
          delta: delta,
          horizontalScrollbarRef: horizontalScrollbarRef,
          verticalScrollbarRef: verticalScrollbarRef
        }, _this.props);

        if (delta !== 0) {
          _this.scrollToAccumulatedTarget(delta, canScrollVertically, _this.props.overscrollEffectOn.wheel);

          ev.preventDefault();
          ev.stopPropagation();
        }
      }
    };

    _this.scrollByPage = function (keyCode) {
      var bounds = _this.getScrollBounds(),
          canScrollVertically = _this.canScrollVertically(bounds),
          pageDistance = (isPageUp(keyCode) ? -1 : 1) * (canScrollVertically ? bounds.clientHeight : bounds.clientWidth) * paginationPageMultiplier;

      _this.lastInputType = 'pageKey';

      _this.scrollToAccumulatedTarget(pageDistance, canScrollVertically, _this.props.overscrollEffectOn.pageKey);
    };

    _this.onKeyDown = function (ev) {
      if (_this.props.onKeyDown) {
        (0, _handle.forward)('onKeyDown', ev, _this.props);
      } else if (isPageUp(ev.keyCode) || isPageDown(ev.keyCode)) {
        _this.scrollByPage(ev.keyCode);
      }
    };

    _this.scrollToAccumulatedTarget = function (delta, vertical, overscrollEffect) {
      if (!_this.isScrollAnimationTargetAccumulated) {
        _this.accumulatedTargetX = _this.scrollLeft;
        _this.accumulatedTargetY = _this.scrollTop;
        _this.isScrollAnimationTargetAccumulated = true;
      }

      if (vertical) {
        _this.accumulatedTargetY += delta;
      } else {
        _this.accumulatedTargetX += delta;
      }

      _this.start({
        targetX: _this.accumulatedTargetX,
        targetY: _this.accumulatedTargetY,
        overscrollEffect: overscrollEffect
      });
    };

    _this.getEdgeFromPosition = function (position, maxPosition) {
      if (position <= 0) {
        return 'before';
      } else if (position >= maxPosition) {
        return 'after';
      } else {
        return null;
      }
    };

    _this.setOverscrollStatus = function (orientation, edge, type, ratio) {
      var status = _this.overscrollStatus[orientation][edge];
      status.type = type;
      status.ratio = ratio;
    };

    _this.getOverscrollStatus = function (orientation, edge) {
      return _this.overscrollStatus[orientation][edge];
    };

    _this.calculateOverscrollRatio = function (orientation, position) {
      var bounds = _this.getScrollBounds(),
          isVertical = orientation === 'vertical',
          baseSize = isVertical ? bounds.clientHeight : bounds.clientWidth,
          maxPos = bounds[isVertical ? 'maxTop' : 'maxLeft'];

      var overDistance = 0;

      if (position < 0) {
        overDistance = -position;
      } else if (position > maxPos) {
        overDistance = position - maxPos;
      } else {
        return 0;
      }

      return Math.min(1, 2 * overDistance / baseSize);
    };

    _this.applyOverscrollEffect = function (orientation, edge, type, ratio) {
      _this.props.applyOverscrollEffect(orientation, edge, type, ratio);

      _this.setOverscrollStatus(orientation, edge, type === overscrollTypeOnce ? overscrollTypeDone : type, ratio);
    };

    _this.checkAndApplyOverscrollEffect = function (orientation, edge, type) {
      var ratio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      var isVertical = orientation === 'vertical',
          curPos = isVertical ? _this.scrollTop : _this.scrollLeft,
          maxPos = _this.getScrollBounds()[isVertical ? 'maxTop' : 'maxLeft'];

      if (edge === 'before' && curPos <= 0 || edge === 'after' && curPos >= maxPos) {
        // Already on the edge
        _this.applyOverscrollEffect(orientation, edge, type, ratio);
      } else {
        _this.setOverscrollStatus(orientation, edge, type, ratio);
      }
    };

    _this.clearOverscrollEffect = function (orientation, edge) {
      if (_this.getOverscrollStatus(orientation, edge).type !== overscrollTypeNone) {
        if (_this.props.clearOverscrollEffect) {
          _this.props.clearOverscrollEffect(orientation, edge);
        } else {
          _this.applyOverscrollEffect(orientation, edge, overscrollTypeNone, 0);
        }
      }
    };

    _this.clearAllOverscrollEffects = function () {
      ['horizontal', 'vertical'].forEach(function (orientation) {
        ['before', 'after'].forEach(function (edge) {
          _this.clearOverscrollEffect(orientation, edge);
        });
      });
    };

    _this.applyOverscrollEffectOnDrag = function (orientation, edge, targetPosition, type) {
      if (edge) {
        var oppositeEdge = edge === 'before' ? 'after' : 'before',
            ratio = _this.calculateOverscrollRatio(orientation, targetPosition);

        _this.applyOverscrollEffect(orientation, edge, type, ratio);

        _this.clearOverscrollEffect(orientation, oppositeEdge);
      } else {
        _this.clearOverscrollEffect(orientation, 'before');

        _this.clearOverscrollEffect(orientation, 'after');
      }
    };

    _this.checkAndApplyOverscrollEffectOnScroll = function (orientation) {
      ['before', 'after'].forEach(function (edge) {
        var _this$getOverscrollSt = _this.getOverscrollStatus(orientation, edge),
            ratio = _this$getOverscrollSt.ratio,
            type = _this$getOverscrollSt.type;

        if (type === overscrollTypeOnce) {
          _this.checkAndApplyOverscrollEffect(orientation, edge, type, ratio);
        }
      });
    };

    _this.checkAndApplyOverscrollEffectOnStart = function (orientation, edge, targetPosition) {
      if (_this.isDragging) {
        _this.applyOverscrollEffectOnDrag(orientation, edge, targetPosition, overscrollTypeHold);
      } else if (edge) {
        _this.checkAndApplyOverscrollEffect(orientation, edge, overscrollTypeOnce);
      }
    };

    _this.getReachedEdgeInfo = function () {
      var bounds = _this.getScrollBounds(),
          reachedEdgeInfo = {
        bottom: false,
        left: false,
        right: false,
        top: false
      };

      if (_this.canScrollHorizontally(bounds)) {
        var rtl = _this.props.rtl,
            edge = _this.getEdgeFromPosition(_this.scrollLeft, bounds.maxLeft);

        if (edge) {
          // if edge is null, no need to check which edge is reached.
          if (edge === 'before' && !rtl || edge === 'after' && rtl) {
            reachedEdgeInfo.left = true;
          } else {
            reachedEdgeInfo.right = true;
          }
        }
      }

      if (_this.canScrollVertically(bounds)) {
        var _edge = _this.getEdgeFromPosition(_this.scrollTop, bounds.maxTop);

        if (_edge === 'before') {
          reachedEdgeInfo.top = true;
        } else if (_edge === 'after') {
          reachedEdgeInfo.bottom = true;
        }
      }

      return reachedEdgeInfo;
    };

    _this.doScrollStop = function () {
      _this.scrolling = false;

      _this.forwardScrollEvent('onScrollStop', _this.getReachedEdgeInfo());
    };

    _this.scrollStopJob = new _util.Job(_this.doScrollStop, scrollStopWaiting);

    _this.scrollAnimation = function (animationInfo) {
      return function (curTime) {
        var sourceX = animationInfo.sourceX,
            sourceY = animationInfo.sourceY,
            targetX = animationInfo.targetX,
            targetY = animationInfo.targetY,
            duration = animationInfo.duration,
            bounds = _this.getScrollBounds();

        if (curTime < duration) {
          var toBeContinued = false,
              curTargetX = sourceX,
              curTargetY = sourceY;

          if (_this.canScrollHorizontally(bounds)) {
            curTargetX = _this.animator.timingFunction(sourceX, targetX, duration, curTime);

            if (Math.abs(curTargetX - targetX) < epsilon) {
              curTargetX = targetX;
            } else {
              toBeContinued = true;
            }
          }

          if (_this.canScrollVertically(bounds)) {
            curTargetY = _this.animator.timingFunction(sourceY, targetY, duration, curTime);

            if (Math.abs(curTargetY - targetY) < epsilon) {
              curTargetY = targetY;
            } else {
              toBeContinued = true;
            }
          }

          _this.scroll(curTargetX, curTargetY, targetX, targetY);

          if (!toBeContinued) {
            _this.stop();
          }
        } else {
          _this.scroll(targetX, targetY, targetX, targetY);

          _this.stop();
        }
      };
    };

    _this.scroll = function (left, top) {
      var _this$childRefCurrent;

      if (left !== _this.scrollLeft) {
        _this.setScrollLeft(left);
      }

      if (top !== _this.scrollTop) {
        _this.setScrollTop(top);
      }

      for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        rest[_key - 2] = arguments[_key];
      }

      (_this$childRefCurrent = _this.childRefCurrent).setScrollPosition.apply(_this$childRefCurrent, [_this.scrollLeft, _this.scrollTop, _this.props.rtl].concat(rest));

      _this.forwardScrollEvent('onScroll');
    };

    _this.getPositionForScrollTo = function (opt) {
      var bounds = _this.getScrollBounds(),
          canScrollHorizontally = _this.canScrollHorizontally(bounds),
          canScrollVertically = _this.canScrollVertically(bounds);

      var itemPos,
          left = null,
          top = null;

      if (opt instanceof Object) {
        if (opt.position instanceof Object) {
          if (canScrollHorizontally) {
            // We need '!=' to check if opt.position.x is null or undefined
            left = opt.position.x != null ? opt.position.x : _this.scrollLeft;
          } else {
            left = 0;
          }

          if (canScrollVertically) {
            // We need '!=' to check if opt.position.y is null or undefined
            top = opt.position.y != null ? opt.position.y : _this.scrollTop;
          } else {
            top = 0;
          }
        } else if (typeof opt.align === 'string') {
          if (canScrollHorizontally) {
            if (opt.align.includes('left')) {
              left = 0;
            } else if (opt.align.includes('right')) {
              left = bounds.maxLeft;
            }
          }

          if (canScrollVertically) {
            if (opt.align.includes('top')) {
              top = 0;
            } else if (opt.align.includes('bottom')) {
              top = bounds.maxTop;
            }
          }
        } else {
          if (typeof opt.index === 'number' && typeof _this.childRefCurrent.getItemPosition === 'function') {
            itemPos = _this.childRefCurrent.getItemPosition(opt.index, opt.stickTo);
          } else if (opt.node instanceof Object) {
            if (opt.node.nodeType === 1 && typeof _this.childRefCurrent.getNodePosition === 'function') {
              itemPos = _this.childRefCurrent.getNodePosition(opt.node);
            }
          }

          if (itemPos) {
            if (canScrollHorizontally) {
              left = itemPos.left;
            }

            if (canScrollVertically) {
              top = itemPos.top;
            }
          }
        }
      }

      return {
        left: left,
        top: top
      };
    };

    _this.scrollTo = function (opt) {
      if (!_this.deferScrollTo) {
        var _this$getPositionForS = _this.getPositionForScrollTo(opt),
            left = _this$getPositionForS.left,
            top = _this$getPositionForS.top;

        if (_this.props.scrollTo) {
          _this.props.scrollTo(opt);
        }

        _this.scrollToInfo = null;

        _this.start({
          targetX: left !== null ? left : _this.scrollLeft,
          targetY: top !== null ? top : _this.scrollTop,
          animate: opt.animate
        });
      } else {
        _this.scrollToInfo = opt;
      }
    };

    _this.canScrollHorizontally = function (bounds) {
      var direction = _this.props.direction;
      return (direction === 'horizontal' || direction === 'both') && bounds.scrollWidth > bounds.clientWidth && !isNaN(bounds.scrollWidth);
    };

    _this.canScrollVertically = function (bounds) {
      var direction = _this.props.direction;
      return (direction === 'vertical' || direction === 'both') && bounds.scrollHeight > bounds.clientHeight && !isNaN(bounds.scrollHeight);
    };

    _this.startHidingThumb = function () {
      if (_this.state.isHorizontalScrollbarVisible && _this.horizontalScrollbarRef.current) {
        _this.horizontalScrollbarRef.current.startHidingThumb();
      }

      if (_this.state.isVerticalScrollbarVisible && _this.verticalScrollbarRef.current) {
        _this.verticalScrollbarRef.current.startHidingThumb();
      }
    };

    _this.updateScrollbars = function () {
      var _this$props = _this.props,
          horizontalScrollbar = _this$props.horizontalScrollbar,
          verticalScrollbar = _this$props.verticalScrollbar,
          _this$state = _this.state,
          isHorizontalScrollbarVisible = _this$state.isHorizontalScrollbarVisible,
          isVerticalScrollbarVisible = _this$state.isVerticalScrollbarVisible,
          bounds = _this.getScrollBounds(),
          canScrollHorizontally = _this.canScrollHorizontally(bounds),
          canScrollVertically = _this.canScrollVertically(bounds),
          curHorizontalScrollbarVisible = horizontalScrollbar === 'auto' ? canScrollHorizontally : horizontalScrollbar === 'visible',
          curVerticalScrollbarVisible = verticalScrollbar === 'auto' ? canScrollVertically : verticalScrollbar === 'visible'; // determine if we should hide or show any scrollbars


      var isVisibilityChanged = isHorizontalScrollbarVisible !== curHorizontalScrollbarVisible || isVerticalScrollbarVisible !== curVerticalScrollbarVisible;

      if (isVisibilityChanged) {
        // one or both scrollbars have changed visibility
        _this.setState({
          isHorizontalScrollbarVisible: curHorizontalScrollbarVisible,
          isVerticalScrollbarVisible: curVerticalScrollbarVisible
        });
      } else {
        _this.deferScrollTo = false;
        _this.isUpdatedScrollThumb = _this.updateScrollThumbSize();
      }
    };

    _this.updateScrollThumbSize = function () {
      var _this$props2 = _this.props,
          horizontalScrollbar = _this$props2.horizontalScrollbar,
          verticalScrollbar = _this$props2.verticalScrollbar,
          bounds = _this.getScrollBounds(),
          canScrollHorizontally = _this.canScrollHorizontally(bounds),
          canScrollVertically = _this.canScrollVertically(bounds),
          curHorizontalScrollbarVisible = horizontalScrollbar === 'auto' ? canScrollHorizontally : horizontalScrollbar === 'visible',
          curVerticalScrollbarVisible = verticalScrollbar === 'auto' ? canScrollVertically : verticalScrollbar === 'visible';

      if (curHorizontalScrollbarVisible || curVerticalScrollbarVisible) {
        // no visibility change but need to notify whichever scrollbars are visible of the
        // updated bounds and scroll position
        var updatedBounds = _objectSpread(_objectSpread({}, bounds), {}, {
          scrollLeft: _this.scrollLeft,
          scrollTop: _this.scrollTop
        });

        if (curHorizontalScrollbarVisible && _this.horizontalScrollbarRef.current) {
          _this.horizontalScrollbarRef.current.update(updatedBounds);
        }

        if (curVerticalScrollbarVisible && _this.verticalScrollbarRef.current) {
          _this.verticalScrollbarRef.current.update(updatedBounds);
        }

        return true;
      }

      return false;
    };

    _this.initChildRef = function (ref) {
      if (ref) {
        _this.childRefCurrent = ref;
      }
    };

    _this.handleScroll = function () {
      var childRefCurrent = _this.childRefCurrent; // Prevent scroll by focus.
      // VirtualList and VirtualGridList DO NOT receive `onscroll` event.
      // Only Scroller could get `onscroll` event.

      if (!_this.animator.isAnimating() && childRefCurrent && childRefCurrent.containerRef.current && childRefCurrent.getRtlPositionX && !_this.isDragging) {
        // For Scroller
        childRefCurrent.containerRef.current.scrollTop = _this.scrollTop;
        childRefCurrent.containerRef.current.scrollLeft = childRefCurrent.getRtlPositionX(_this.scrollLeft);
      }
    };

    _this.state = {
      remeasure: false,
      isHorizontalScrollbarVisible: props.horizontalScrollbar === 'visible',
      isVerticalScrollbarVisible: props.verticalScrollbar === 'visible'
    };
    _this.containerRef = /*#__PURE__*/(0, _react.createRef)();
    _this.horizontalScrollbarRef = /*#__PURE__*/(0, _react.createRef)();
    _this.verticalScrollbarRef = /*#__PURE__*/(0, _react.createRef)();
    _this.horizontalScrollbarProps = {
      ref: _this.horizontalScrollbarRef,
      vertical: false,
      clientSize: props.clientSize
    };
    _this.verticalScrollbarProps = {
      ref: _this.verticalScrollbarRef,
      vertical: true,
      clientSize: props.clientSize
    };
    _this.overscrollEnabled = !!props.applyOverscrollEffect; // Enable the early bail out of repeated scrolling to the same position

    _this.animationInfo = null;
    _this.resizeRegistry = _Registry["default"].create(_this.handleResize.bind(_assertThisInitialized(_this)));
    props.cbScrollTo(_this.scrollTo);
    return _this;
  }

  _createClass(ScrollableBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.resizeRegistry.parent = this.context;
      this.addEventListeners();
      this.updateScrollbars();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this$state2 = this.state,
          isHorizontalScrollbarVisible = _this$state2.isHorizontalScrollbarVisible,
          isVerticalScrollbarVisible = _this$state2.isVerticalScrollbarVisible,
          hasDataSizeChanged = this.childRefCurrent.hasDataSizeChanged; // Need to sync calculated client size if it is different from the real size

      if (this.childRefCurrent.syncClientSize) {
        // If we actually synced, we need to reset scroll position.
        if (this.childRefCurrent.syncClientSize()) {
          this.setScrollLeft(0);
          this.setScrollTop(0);
        }
      }

      this.clampScrollPosition();
      this.addEventListeners();

      if (hasDataSizeChanged === false && (isHorizontalScrollbarVisible && !prevState.isHorizontalScrollbarVisible || isVerticalScrollbarVisible && !prevState.isVerticalScrollbarVisible)) {
        this.deferScrollTo = false;
        this.isUpdatedScrollThumb = this.updateScrollThumbSize();
      } else {
        this.updateScrollbars();
      }

      if (this.scrollToInfo !== null) {
        if (!this.deferScrollTo) {
          this.scrollTo(this.scrollToInfo);
        }
      } // publish container resize changes


      var horizontal = isHorizontalScrollbarVisible !== prevState.isHorizontalScrollbarVisible;
      var vertical = isVerticalScrollbarVisible !== prevState.isVerticalScrollbarVisible;

      if (horizontal || vertical) {
        this.resizeRegistry.notify({});
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.resizeRegistry.parent = null; // Before call cancelAnimationFrame, you must send scrollStop Event.

      if (this.scrolling) {
        this.forwardScrollEvent('onScrollStop', this.getReachedEdgeInfo());
      }

      this.scrollStopJob.stop();

      if (this.animator.isAnimating()) {
        this.animator.stop();
      }

      this.removeEventListeners();
    }
  }, {
    key: "handleResize",
    value: function handleResize(ev) {
      if (ev.action === 'invalidateBounds') {
        this.enqueueForceUpdate();
      }
    }
  }, {
    key: "enqueueForceUpdate",
    value: // TODO: consider replacing forceUpdate() by storing bounds in state rather than a non-
    // state member.
    function enqueueForceUpdate() {
      this.childRefCurrent.calculateMetrics(this.childRefCurrent.props);
      this.forceUpdate();
    }
  }, {
    key: "clampScrollPosition",
    value: function clampScrollPosition() {
      var bounds = this.getScrollBounds();

      if (this.scrollTop > bounds.maxTop) {
        this.scrollTop = bounds.maxTop;
      }

      if (this.scrollLeft > bounds.maxLeft) {
        this.scrollLeft = bounds.maxLeft;
      }
    } // constants

  }, {
    key: "calculateDistanceByWheel",
    value: function calculateDistanceByWheel(deltaMode, delta, maxPixel) {
      if (deltaMode === 0) {
        delta = (0, _clamp["default"])(-maxPixel, maxPixel, _resolution["default"].scale(delta * this.scrollWheelMultiplierForDeltaPixel));
      } else if (deltaMode === 1) {
        // line; firefox
        delta = (0, _clamp["default"])(-maxPixel, maxPixel, _resolution["default"].scale(delta * this.pixelPerLine * this.scrollWheelMultiplierForDeltaPixel));
      } else if (deltaMode === 2) {
        // page
        delta = delta < 0 ? -maxPixel : maxPixel;
      }

      return delta;
    }
  }, {
    key: "forwardScrollEvent",
    value: // call scroll callbacks
    function forwardScrollEvent(type, reachedEdgeInfo) {
      (0, _handle.forward)(type, {
        type: type,
        scrollLeft: this.scrollLeft,
        scrollTop: this.scrollTop,
        moreInfo: this.getMoreInfo(),
        reachedEdgeInfo: reachedEdgeInfo
      }, this.props);
    } // update scroll position

  }, {
    key: "setScrollLeft",
    value: function setScrollLeft(value) {
      var bounds = this.getScrollBounds();
      this.scrollLeft = (0, _clamp["default"])(0, bounds.maxLeft, value);

      if (this.overscrollEnabled && this.props.overscrollEffectOn[this.lastInputType]) {
        this.checkAndApplyOverscrollEffectOnScroll('horizontal');
      }

      if (this.state.isHorizontalScrollbarVisible) {
        this.updateThumb(this.horizontalScrollbarRef, bounds);
      }
    }
  }, {
    key: "setScrollTop",
    value: function setScrollTop(value) {
      var bounds = this.getScrollBounds();
      this.scrollTop = (0, _clamp["default"])(0, bounds.maxTop, value);

      if (this.overscrollEnabled && this.props.overscrollEffectOn[this.lastInputType]) {
        this.checkAndApplyOverscrollEffectOnScroll('vertical');
      }

      if (this.state.isVerticalScrollbarVisible) {
        this.updateThumb(this.verticalScrollbarRef, bounds);
      }
    }
  }, {
    key: "start",
    value: function start(_ref) {
      var targetX = _ref.targetX,
          targetY = _ref.targetY,
          _ref$animate = _ref.animate,
          animate = _ref$animate === void 0 ? true : _ref$animate,
          _ref$duration = _ref.duration,
          duration = _ref$duration === void 0 ? animationDuration : _ref$duration,
          _ref$overscrollEffect = _ref.overscrollEffect,
          overscrollEffect = _ref$overscrollEffect === void 0 ? false : _ref$overscrollEffect;
      var scrollLeft = this.scrollLeft,
          scrollTop = this.scrollTop,
          bounds = this.getScrollBounds(),
          maxLeft = bounds.maxLeft,
          maxTop = bounds.maxTop;
      var updatedAnimationInfo = {
        sourceX: scrollLeft,
        sourceY: scrollTop,
        targetX: targetX,
        targetY: targetY,
        duration: duration
      }; // bail early when scrolling to the same position

      if (this.animator.isAnimating() && this.animationInfo && this.animationInfo.targetX === targetX && this.animationInfo.targetY === targetY) {
        return;
      }

      this.animationInfo = updatedAnimationInfo;
      this.animator.stop();

      if (!this.scrolling) {
        this.scrolling = true;
        this.forwardScrollEvent('onScrollStart');
      }

      this.scrollStopJob.stop();

      if (Math.abs(maxLeft - targetX) < epsilon) {
        targetX = maxLeft;
      }

      if (Math.abs(maxTop - targetY) < epsilon) {
        targetY = maxTop;
      }

      if (this.overscrollEnabled && overscrollEffect) {
        if (scrollLeft !== targetX && this.canScrollHorizontally(bounds)) {
          this.checkAndApplyOverscrollEffectOnStart('horizontal', this.getEdgeFromPosition(targetX, maxLeft), targetX);
        }

        if (scrollTop !== targetY && this.canScrollVertically(bounds)) {
          this.checkAndApplyOverscrollEffectOnStart('vertical', this.getEdgeFromPosition(targetY, maxTop), targetY);
        }
      }

      this.showThumb(bounds);

      if (animate) {
        this.animator.animate(this.scrollAnimation(this.animationInfo));
      } else {
        this.scroll(targetX, targetY, targetX, targetY);
        this.stop();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      this.animator.stop();
      this.lastInputType = null;
      this.isScrollAnimationTargetAccumulated = false;
      this.startHidingThumb();

      if (this.overscrollEnabled && !this.isDragging) {
        // not check this.props.overscrollEffectOn for safety
        this.clearAllOverscrollEffects();
      }

      if (this.props.stop) {
        this.props.stop();
      }

      if (this.scrolling) {
        this.scrollStopJob.start();
      }
    } // scrollTo API

  }, {
    key: "showThumb",
    value: // scroll bar
    function showThumb(bounds) {
      if (this.state.isHorizontalScrollbarVisible && this.canScrollHorizontally(bounds) && this.horizontalScrollbarRef.current) {
        this.horizontalScrollbarRef.current.showThumb();
      }

      if (this.state.isVerticalScrollbarVisible && this.canScrollVertically(bounds) && this.verticalScrollbarRef.current) {
        this.verticalScrollbarRef.current.showThumb();
      }
    }
  }, {
    key: "updateThumb",
    value: function updateThumb(scrollbarRef, bounds) {
      scrollbarRef.current.update(_objectSpread(_objectSpread({}, bounds), {}, {
        scrollLeft: this.scrollLeft,
        scrollTop: this.scrollTop
      }));
    }
  }, {
    key: "getScrollBounds",
    value: // ref
    function getScrollBounds() {
      if (this.childRefCurrent && typeof this.childRefCurrent.getScrollBounds === 'function') {
        return this.childRefCurrent.getScrollBounds();
      }
    }
  }, {
    key: "getMoreInfo",
    value: function getMoreInfo() {
      if (this.childRefCurrent && typeof this.childRefCurrent.getMoreInfo === 'function') {
        return this.childRefCurrent.getMoreInfo();
      }
    } // FIXME setting event handlers directly to work on the V8 snapshot.

  }, {
    key: "addEventListeners",
    value: function addEventListeners() {
      var childRefCurrent = this.childRefCurrent,
          containerRef = this.containerRef;

      if (containerRef.current && containerRef.current.addEventListener) {
        containerRef.current.addEventListener('wheel', this.onWheel);
        containerRef.current.addEventListener('keydown', this.onKeyDown);
        containerRef.current.addEventListener('mousedown', this.onMouseDown);
      }

      if (this.props.addEventListeners) {
        this.props.addEventListeners(childRefCurrent.containerRef);
      }

      if (window) {
        window.addEventListener('resize', this.handleResizeWindow);
      }
    } // FIXME setting event handlers directly to work on the V8 snapshot.

  }, {
    key: "removeEventListeners",
    value: function removeEventListeners() {
      var childRefCurrent = this.childRefCurrent,
          containerRef = this.containerRef;

      if (containerRef.current && containerRef.current.removeEventListener) {
        containerRef.current.removeEventListener('wheel', this.onWheel);
        containerRef.current.removeEventListener('keydown', this.onKeyDown);
        containerRef.current.removeEventListener('mousedown', this.onMouseDown);
      }

      if (this.props.removeEventListeners) {
        this.props.removeEventListeners(childRefCurrent.containerRef);
      }

      if (window) {
        window.removeEventListener('resize', this.handleResizeWindow);
      }
    } // render

  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          className = _this$props3.className,
          containerRenderer = _this$props3.containerRenderer,
          noScrollByDrag = _this$props3.noScrollByDrag,
          rtl = _this$props3.rtl,
          style = _this$props3.style,
          rest = _objectWithoutProperties(_this$props3, _excluded),
          _this$state3 = this.state,
          isHorizontalScrollbarVisible = _this$state3.isHorizontalScrollbarVisible,
          isVerticalScrollbarVisible = _this$state3.isVerticalScrollbarVisible,
          scrollableClasses = (0, _classnames["default"])(_ScrollableModule["default"].scrollable, className),
          childWrapper = noScrollByDrag ? 'div' : TouchableDiv,
          childWrapperProps = _objectSpread({
        className: _ScrollableModule["default"].content
      }, !noScrollByDrag && {
        flickConfig: flickConfig,
        onDrag: this.onDrag,
        onDragEnd: this.onDragEnd,
        onDragStart: this.onDragStart,
        onFlick: this.onFlick
      });

      delete rest.addEventListeners;
      delete rest.applyOverscrollEffect;
      delete rest.cbScrollTo;
      delete rest.clearOverscrollEffect;
      delete rest.handleResizeWindow;
      delete rest.horizontalScrollbar;
      delete rest.noScrollByWheel;
      delete rest.onFlick;
      delete rest.onKeyDown;
      delete rest.onMouseDown;
      delete rest.onScroll;
      delete rest.onScrollStart;
      delete rest.onScrollStop;
      delete rest.onWheel;
      delete rest.overscrollEffectOn;
      delete rest.removeEventListeners;
      delete rest.scrollTo;
      delete rest.stop;
      delete rest.verticalScrollbar;
      this.deferScrollTo = true;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Resizable.ResizeContext.Provider, {
        value: this.resizeRegistry.register,
        children: containerRenderer({
          childComponentProps: rest,
          childWrapper: childWrapper,
          childWrapperProps: childWrapperProps,
          className: scrollableClasses,
          componentCss: _ScrollableModule["default"],
          containerRef: this.containerRef,
          handleScroll: this.handleScroll,
          horizontalScrollbarProps: this.horizontalScrollbarProps,
          initChildRef: this.initChildRef,
          isHorizontalScrollbarVisible: isHorizontalScrollbarVisible,
          isVerticalScrollbarVisible: isVerticalScrollbarVisible,
          rtl: rtl,
          scrollTo: this.scrollTo,
          style: style,
          verticalScrollbarProps: this.verticalScrollbarProps
        })
      });
    }
  }]);

  return ScrollableBase;
}(_react.Component);
/**
 * An unstyled component that provides horizontal and vertical scrollbars and makes a render prop element scrollable.
 *
 * @class Scrollable
 * @memberof ui/Scrollable
 * @extends ui/Scrollable.ScrollableBase
 * @ui
 * @private
 */


exports.ScrollableBase = ScrollableBase;
ScrollableBase.displayName = 'ui:ScrollableBase';
ScrollableBase.propTypes =
/** @lends ui/Scrollable.Scrollable.prototype */
{
  /**
   * Render function.
   *
   * @type {Function}
   * @required
   * @private
   */
  containerRenderer: _propTypes["default"].func.isRequired,

  /**
   * Called when adding additional event listeners in a themed component.
   *
   * @type {Function}
   * @private
   */
  addEventListeners: _propTypes["default"].func,

  /**
   * Called to execute additional logic in a themed component to show overscroll effect.
   *
   * @type {Function}
   * @private
   */
  applyOverscrollEffect: _propTypes["default"].func,

  /**
   * A callback function that receives a reference to the `scrollTo` feature.
   *
   * Once received, the `scrollTo` method can be called as an imperative interface.
   *
   * The `scrollTo` function accepts the following parameters:
   * - {position: {x, y}} - Pixel value for x and/or y position
   * - {align} - Where the scroll area should be aligned. Values are:
   *   `'left'`, `'right'`, `'top'`, `'bottom'`,
   *   `'topleft'`, `'topright'`, `'bottomleft'`, and `'bottomright'`.
   * - {index} - Index of specific item. (`0` or positive integer)
   *   This option is available for only `VirtualList` kind.
   * - {node} - Node to scroll into view
   * - {animate} - When `true`, scroll occurs with animation. When `false`, no
   *   animation occurs.
   * - {focus} - When `true`, attempts to focus item after scroll. Only valid when scrolling
   *   by `index` or `node`.
   * > Note: Only specify one of: `position`, `align`, `index` or `node`
   *
   * Example:
   * ```
   *	// If you set cbScrollTo prop like below;
   *	cbScrollTo: (fn) => {this.scrollTo = fn;}
   *	// You can simply call like below;
   *	this.scrollTo({align: 'top'}); // scroll to the top
   * ```
   *
   * @type {Function}
   * @public
   */
  cbScrollTo: _propTypes["default"].func,

  /**
   * Called to execute additional logic in a themed component to clear overscroll effect.
   *
   * @type {Function}
   * @private
   */
  clearOverscrollEffect: _propTypes["default"].func,

  /**
   * Client size of the container; valid values are an object that has `clientWidth` and `clientHeight`.
   *
   * @type {Object}
   * @property {Number}    clientHeight    The client height of the list.
   * @property {Number}    clientWidth    The client width of the list.
   * @public
   */
  clientSize: _propTypes["default"].shape({
    clientHeight: _propTypes["default"].number.isRequired,
    clientWidth: _propTypes["default"].number.isRequired
  }),

  /**
   * Direction of the list or the scroller.
   *
   * `'both'` could be only used for[Scroller]{@link ui/Scroller.Scroller}.
   *
   * Valid values are:
   * * `'both'`,
   * * `'horizontal'`, and
   * * `'vertical'`.
   *
   * @type {String}
   * @private
   */
  direction: _propTypes["default"].oneOf(['both', 'horizontal', 'vertical']),

  /**
   * Called when resizing window
   *
   * @type {Function}
   * @private
   */
  handleResizeWindow: _propTypes["default"].func,

  /**
   * Specifies how to show horizontal scrollbar.
   *
   * Valid values are:
   * * `'auto'`,
   * * `'visible'`, and
   * * `'hidden'`.
   *
   * @type {String}
   * @default 'auto'
   * @public
   */
  horizontalScrollbar: _propTypes["default"].oneOf(['auto', 'visible', 'hidden']),

  /**
   * Prevents scroll by dragging or flicking on the list or the scroller.
   *
   * @type {Boolean}
   * @default false
   * @private
   */
  noScrollByDrag: _propTypes["default"].bool,

  /**
   * Prevents scroll by wheeling on the list or the scroller.
   *
   * @type {Boolean}
   * @default false
   * @public
   */
  noScrollByWheel: _propTypes["default"].bool,

  /**
   * Called when triggering a drag event.
   *
   * @type {Function}
   * @private
   */
  onDrag: _propTypes["default"].func,

  /**
   * Called when triggering a dragend event.
   *
   * @type {Function}
   * @private
   */
  onDragEnd: _propTypes["default"].func,

  /**
   * Called when triggering a dragstart event.
   *
   * @type {Function}
   * @private
   */
  onDragStart: _propTypes["default"].func,

  /**
   * Called when flicking with a mouse or a touch screen.
   *
   * @type {Function}
   * @private
   */
  onFlick: _propTypes["default"].func,

  /**
   * Called when pressing a key.
   *
   * @type {Function}
   * @private
   */
  onKeyDown: _propTypes["default"].func,

  /**
   * Called when triggering a mousedown event.
   *
   * @type {Function}
   * @private
   */
  onMouseDown: _propTypes["default"].func,

  /**
   * Called when scrolling.
   *
   * Passes `scrollLeft`, `scrollTop`, and `moreInfo`.
   * It is not recommended to set this prop since it can cause performance degradation.
   * Use `onScrollStart` or `onScrollStop` instead.
   *
   * @type {Function}
   * @param {Object} event
   * @param {Number} event.scrollLeft Scroll left value.
   * @param {Number} event.scrollTop Scroll top value.
   * @param {Object} event.moreInfo The object including `firstVisibleIndex` and `lastVisibleIndex` properties.
   * @public
   */
  onScroll: _propTypes["default"].func,

  /**
   * Called when scroll starts.
   *
   * Passes `scrollLeft`, `scrollTop`, and `moreInfo`.
   * You can get firstVisibleIndex and lastVisibleIndex from VirtualList with `moreInfo`.
   *
   * Example:
   * ```
   * onScrollStart = ({scrollLeft, scrollTop, moreInfo}) => {
   *     const {firstVisibleIndex, lastVisibleIndex} = moreInfo;
   *     // do something with firstVisibleIndex and lastVisibleIndex
   * }
   *
   * render = () => (
   *     <VirtualList
   *         ...
   *         onScrollStart={this.onScrollStart}
   *         ...
   *     />
   * )
   * ```
   *
   * @type {Function}
   * @param {Object} event
   * @param {Number} event.scrollLeft Scroll left value.
   * @param {Number} event.scrollTop Scroll top value.
   * @param {Object} event.moreInfo The object including `firstVisibleIndex` and `lastVisibleIndex` properties.
   * @public
   */
  onScrollStart: _propTypes["default"].func,

  /**
   * Called when scroll stops.
   *
   * Passes `scrollLeft`, `scrollTop`, and `moreInfo`.
   * You can get firstVisibleIndex and lastVisibleIndex from VirtualList with `moreInfo`.
   *
   * Example:
   * ```
   * onScrollStop = ({scrollLeft, scrollTop, moreInfo}) => {
   *     const {firstVisibleIndex, lastVisibleIndex} = moreInfo;
   *     // do something with firstVisibleIndex and lastVisibleIndex
   * }
   *
   * render = () => (
   *     <VirtualList
   *         ...
   *         onScrollStop={this.onScrollStop}
   *         ...
   *     />
   * )
   * ```
   *
   * @type {Function}
   * @param {Object} event
   * @param {Number} event.scrollLeft Scroll left value.
   * @param {Number} event.scrollTop Scroll top value.
   * @param {Object} event.moreInfo The object including `firstVisibleIndex` and `lastVisibleIndex` properties.
   * @public
   */
  onScrollStop: _propTypes["default"].func,

  /**
   * Called when wheeling.
   *
   * @type {Function}
   * @private
   */
  onWheel: _propTypes["default"].func,

  /**
   * Specifies overscroll effects shows on which type of inputs.
   *
   * @type {Object}
   * @default {drag: false, pageKey: false, wheel: false}
   * @private
   */
  overscrollEffectOn: _propTypes["default"].shape({
    drag: _propTypes["default"].bool,
    pageKey: _propTypes["default"].bool,
    wheel: _propTypes["default"].bool
  }),

  /**
   * Called when removing additional event listeners in a themed component.
   *
   * @type {Function}
   * @private
   */
  removeEventListeners: _propTypes["default"].func,

  /**
   * Indicates the content's text direction is right-to-left.
   *
   * @type {Boolean}
   * @private
   */
  rtl: _propTypes["default"].bool,

  /**
   * Called to execute additional logic in a themed component when scrollTo is called.
   *
   * @type {Function}
   * @private
   */
  scrollTo: _propTypes["default"].func,

  /**
   * Called to execute additional logic in a themed component when scroll stops.
   *
   * @type {Function}
   * @private
   */
  stop: _propTypes["default"].func,

  /**
   * Specifies how to show vertical scrollbar.
   *
   * Valid values are:
   * * `'auto'`,
   * * `'visible'`, and
   * * `'hidden'`.
   *
   * @type {String}
   * @default 'auto'
   * @public
   */
  verticalScrollbar: _propTypes["default"].oneOf(['auto', 'visible', 'hidden'])
};
ScrollableBase.defaultProps = {
  cbScrollTo: nop,
  horizontalScrollbar: 'auto',
  noScrollByDrag: false,
  noScrollByWheel: false,
  onScroll: nop,
  onScrollStart: nop,
  onScrollStop: nop,
  overscrollEffectOn: {
    drag: false,
    pageKey: false,
    wheel: false
  },
  verticalScrollbar: 'auto'
};
ScrollableBase.contextType = _Resizable.ResizeContext;

var Scrollable = /*#__PURE__*/function (_Component2) {
  _inherits(Scrollable, _Component2);

  var _super2 = _createSuper(Scrollable);

  function Scrollable() {
    _classCallCheck(this, Scrollable);

    return _super2.apply(this, arguments);
  }

  _createClass(Scrollable, [{
    key: "render",
    value: function render() {
      var _this$props4 = this.props,
          childRenderer = _this$props4.childRenderer,
          rest = _objectWithoutProperties(_this$props4, _excluded2);

      return /*#__PURE__*/(0, _jsxRuntime.jsx)(ScrollableBase, _objectSpread(_objectSpread({}, rest), {}, {
        containerRenderer: function containerRenderer(_ref2) {
          var childComponentProps = _ref2.childComponentProps,
              ChildWrapper = _ref2.childWrapper,
              childWrapperProps = _ref2.childWrapperProps,
              containerRef = _ref2.containerRef,
              className = _ref2.className,
              componentCss = _ref2.componentCss,
              handleScroll = _ref2.handleScroll,
              horizontalScrollbarProps = _ref2.horizontalScrollbarProps,
              initChildRef = _ref2.initChildRef,
              isHorizontalScrollbarVisible = _ref2.isHorizontalScrollbarVisible,
              isVerticalScrollbarVisible = _ref2.isVerticalScrollbarVisible,
              rtl = _ref2.rtl,
              scrollTo = _ref2.scrollTo,
              style = _ref2.style,
              verticalScrollbarProps = _ref2.verticalScrollbarProps;
          return /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
            className: className,
            ref: containerRef,
            style: style,
            children: [/*#__PURE__*/(0, _jsxRuntime.jsxs)("div", {
              className: componentCss.container,
              children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(ChildWrapper, _objectSpread(_objectSpread({}, childWrapperProps), {}, {
                children: childRenderer(_objectSpread(_objectSpread({}, childComponentProps), {}, {
                  cbScrollTo: scrollTo,
                  className: componentCss.scrollableFill,
                  initChildRef: initChildRef,
                  onScroll: handleScroll,
                  rtl: rtl
                }))
              })), isVerticalScrollbarVisible ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scrollbar["default"], _objectSpread(_objectSpread({}, verticalScrollbarProps), {}, {
                disabled: !isVerticalScrollbarVisible
              })) : null]
            }), isHorizontalScrollbarVisible ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scrollbar["default"], _objectSpread(_objectSpread({}, horizontalScrollbarProps), {}, {
              corner: isVerticalScrollbarVisible,
              disabled: !isHorizontalScrollbarVisible
            })) : null]
          });
        }
      }));
    }
  }]);

  return Scrollable;
}(_react.Component);

exports.Scrollable = Scrollable;
Scrollable.displayName = 'ui:Scrollable';
Scrollable.propTypes =
/** @lends ui/Scrollable.Scrollable.prototype */
{
  /**
   * Render function.
   *
   * @type {Function}
   * @required
   * @private
   */
  childRenderer: _propTypes["default"].func.isRequired
};
var _default = Scrollable;
exports["default"] = _default;