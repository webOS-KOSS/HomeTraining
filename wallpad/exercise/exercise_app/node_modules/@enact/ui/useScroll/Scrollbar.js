"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScrollbarBase = exports.Scrollbar = void 0;
Object.defineProperty(exports, "ScrollbarTrack", {
  enumerable: true,
  get: function get() {
    return _ScrollbarTrack["default"];
  }
});
exports.useScrollbar = exports["default"] = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _util = require("@enact/core/util");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = require("react");

var _resolution = _interopRequireDefault(require("../resolution"));

var _ScrollbarTrack = _interopRequireDefault(require("./ScrollbarTrack"));

var _ScrollbarModule = _interopRequireDefault(require("./Scrollbar.module.css"));

var _jsxRuntime = require("react/jsx-runtime");

var _excluded = ["className", "clientSize", "corner", "css", "minThumbSize", "scrollbarHandle", "vertical"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var scrollbarTrackHidingDelay = 900; // 900ms + 100ms(fade out duration) = 1000ms.

var addClass = function addClass(element, className) {
  if (element) {
    element.classList.add(className);
  }
};

var removeClass = function removeClass(element, className) {
  if (element) {
    element.classList.remove(className);
  }
};
/*
 * Set CSS Variable value.
 *
 * @method
 * @param {Node} element - Node.
 * @param {String} variable - CSS Variable property.
 * @param {String} value - CSS Variable value.
 */


var setCSSVariable = function setCSSVariable(element, variable, value) {
  element.style.setProperty(variable, value);
};
/**
 * A custom hook that passes scrollbar behavior information as its render prop.
 *
 * @class
 * @memberof ui/useScroll
 * @ui
 * @private
 */


var useScrollbar = function useScrollbar(props) {
  var className = props.className,
      clientSize = props.clientSize,
      corner = props.corner,
      css = props.css,
      minThumbSize = props.minThumbSize,
      scrollbarHandle = props.scrollbarHandle,
      vertical = props.vertical,
      rest = _objectWithoutProperties(props, _excluded); // Refs


  var scrollbarContainerRef = (0, _react.useRef)();
  var scrollbarTrackRef = (0, _react.useRef)();
  var hideScrollbarTrackJob = (0, _react.useRef)(null);
  hideScrollbarTrackJob.current = hideScrollbarTrackJob.current || new _util.Job(hideScrollbarTrack, scrollbarTrackHidingDelay);

  function hideScrollbarTrack() {
    removeClass(scrollbarTrackRef.current, css.scrollbarTrackShown);
  }

  (0, _react.useEffect)(function () {
    return function () {
      hideScrollbarTrackJob.current.stop();
    };
  }, []);

  function getContainerRef() {
    return scrollbarContainerRef;
  }

  function showScrollbarTrack() {
    hideScrollbarTrackJob.current.stop();
    addClass(scrollbarTrackRef.current, css.scrollbarTrackShown);
  }

  function startHidingScrollbarTrack() {
    hideScrollbarTrackJob.current.start();
  }

  function update(bounds) {
    var primaryDimension = vertical ? 'clientHeight' : 'clientWidth',
        trackSize = clientSize ? clientSize[primaryDimension] : scrollbarContainerRef.current[primaryDimension],
        scrollViewSize = vertical ? bounds.clientHeight : bounds.clientWidth,
        scrollContentSize = vertical ? bounds.scrollHeight : bounds.scrollWidth,
        scrollOrigin = vertical ? bounds.scrollTop : bounds.scrollLeft,
        scrollbarThumbSizeRatioBase = scrollViewSize / scrollContentSize,
        scrollbarThumbProgressRatio = scrollOrigin / (scrollContentSize - scrollViewSize),
        scrollbarThumbSizeRatio = Math.max(_resolution["default"].scale(minThumbSize) / trackSize, Math.min(1, scrollbarThumbSizeRatioBase));
    setCSSVariable(scrollbarTrackRef.current, '--scrollbar-thumb-size-ratio', scrollbarThumbSizeRatio);
    setCSSVariable(scrollbarTrackRef.current, '--scrollbar-thumb-progress-ratio', scrollbarThumbProgressRatio);
  }

  if (scrollbarHandle) {
    scrollbarHandle.current = {
      getContainerRef: getContainerRef,
      showScrollbarTrack: showScrollbarTrack,
      startHidingScrollbarTrack: startHidingScrollbarTrack,
      update: update
    };
  }

  return {
    restProps: rest,
    scrollbarProps: {
      className: (0, _classnames["default"])(className, corner ? css.corner : null, css.scrollbar, vertical ? css.vertical : css.horizontal),
      ref: scrollbarContainerRef
    },
    scrollbarTrackProps: {
      ref: scrollbarTrackRef,
      vertical: vertical
    }
  };
};
/**
 * An unstyled scroll bar.
 *
 * @class Scrollbar
 * @memberof ui/useScroll
 * @ui
 * @private
 */


exports.useScrollbar = useScrollbar;
var Scrollbar = /*#__PURE__*/(0, _react.memo)(function (props) {
  var _useScrollbar = useScrollbar(props),
      restProps = _useScrollbar.restProps,
      scrollbarProps = _useScrollbar.scrollbarProps,
      scrollbarTrackProps = _useScrollbar.scrollbarTrackProps;

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", _objectSpread(_objectSpread(_objectSpread({}, restProps), scrollbarProps), {}, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_ScrollbarTrack["default"], _objectSpread({}, scrollbarTrackProps))
  }));
});
exports.ScrollbarBase = exports.Scrollbar = Scrollbar;
Scrollbar.displayName = 'ui:Scrollbar';
Scrollbar.propTypes =
/** @lends ui/useScroll.Scrollbar.prototype */
{
  /**
   * Client size of the container; valid values are an object that has `clientWidth` and `clientHeight`.
   *
   * @type {Object}
   * @property {Number}    clientHeight    The client height of the list.
   * @property {Number}    clientWidth    The client width of the list.
   * @public
   */
  clientSize: _propTypes["default"].shape({
    clientHeight: _propTypes["default"].number.isRequired,
    clientWidth: _propTypes["default"].number.isRequired
  }),

  /**
   * Adds a corner between the vertical and horizontal scrollbars.
   *
   * @type {Boolean}
   * @default false
   * @public
   */
  corner: _propTypes["default"].bool,

  /**
   * Customizes the component by mapping the supplied collection of CSS class names to the
   * corresponding internal elements and states of this component.
   *
   * The following classes are supported:
   *
   * * `scrollbar` - The scrollbar component class
   *
   * @type {Object}
   * @public
   */
  css: _propTypes["default"].object,

  /**
   * The minimum size of the thumb.
   *
   * This value will be scaled.
   *
   * @type {number}
   * @public
   */
  minThumbSize: _propTypes["default"].number,

  /**
   * If `true`, the scrollbar will be oriented vertically.
   *
   * @type {Boolean}
   * @default true
   * @public
   */
  vertical: _propTypes["default"].bool
};
Scrollbar.defaultProps = {
  corner: false,
  css: _ScrollbarModule["default"],
  minThumbSize: 18,
  vertical: true
};
var _default = Scrollbar;
exports["default"] = _default;