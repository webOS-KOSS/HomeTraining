"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeModal = exports.addModal = void 0;

var _dispatcher = require("@enact/core/dispatcher");

// Contains references to modal Cancelable instances in LIFO order to allow multiple modals to be
// displayed with the last having the first priority to handle the cancel.
var modals = [];
/**
 * Dispatches the cancel event to each modal `Cancelable` instance. Consistent with
 * {@link core/handle.handle}, returning a `true` value means the event was handled and anything
 * falsy allows the event to pass to the next handler.
 *
 * @param	{Object}	ev	Event payload
 *
 * @returns	{undefined}
 * @private
 */

var dispatchToModals = function dispatchToModals(ev) {
  for (var i = modals.length - 1, handled = false; !handled && i >= 0; i--) {
    handled = modals[i].handleCancel(ev);
  }
};
/**
 * Adds a modal `Cancelable` instance to the list of modals.
 *
 * @param	{ui/Cancelable.Cancelable}	obj	Cancelable instance
 *
 * @returns	{undefined}
 * @private
 */


var addModal = function addModal(obj) {
  if (modals.push(obj) === 1 && typeof window !== 'undefined') {
    (0, _dispatcher.on)('keyup', dispatchToModals, window);
  }
};
/**
 * Removes a modal `Cancelable` instance from the list of modals.
 *
 * @param	{ui/Cancelable.Cancelable}	obj	Cancelable instance
 *
 * @returns	{undefined}
 * @private
 */


exports.addModal = addModal;

var removeModal = function removeModal(obj) {
  var index = modals.indexOf(obj);

  if (index >= 0) {
    modals.splice(index, 1);
  }

  if (modals.length === 0 && typeof window !== 'undefined') {
    (0, _dispatcher.off)('keyup', dispatchToModals, window);
  }
};

exports.removeModal = removeModal;