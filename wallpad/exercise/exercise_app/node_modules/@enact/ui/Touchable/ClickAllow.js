"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.ClickAllow = void 0;

var _platform = require("@enact/core/platform");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// It's possible that emitting `onTap` will cause a DOM change before the mousedown fires resulting
// in multiple tap/click events for the same user action. To avoid this, we store the last touchend
// target and timestamp to compare against the next mouse down. If the timestamp is different (e.g
// we're on a hybrid device that emitted a touch event but the next was a mouse event) or the target
// is the same (or no previous target was set if no touch events have been emitted), we allow the
// mousedown *across Touchable instances*.
var _lastTouchEnd = {
  target: null,
  timeStamp: 0
};

var shouldAllowMouseDown = function shouldAllowMouseDown(ev) {
  return ev.timeStamp !== _lastTouchEnd.timeStamp || ev.target === _lastTouchEnd.target || _lastTouchEnd.target === null;
};

var ClickAllow = /*#__PURE__*/function () {
  function ClickAllow() {
    _classCallCheck(this, ClickAllow);

    this.lastTouchEndTime = 0;
    this.lastMouseUpTime = 0;
  }

  _createClass(ClickAllow, [{
    key: "setLastTouchEnd",
    value: function setLastTouchEnd(ev) {
      if (ev && ev.type === 'touchend') {
        this.lastTouchEndTime = ev.timeStamp;
        _lastTouchEnd.timeStamp = ev.timeStamp;
        _lastTouchEnd.target = ev.target;
      }
    }
  }, {
    key: "setLastMouseUp",
    value: function setLastMouseUp(ev) {
      if (ev && ev.type === 'mouseup') {
        this.lastMouseUpTime = ev.timeStamp;
      }
    }
  }, {
    key: "shouldAllowMouseEvent",
    value: function shouldAllowMouseEvent(ev) {
      var timeStamp = ev.timeStamp; // iOS Safari sends both touch and mouse events (with differing timestamps)

      return !_platform.platform.ios && this.lastTouchEndTime !== timeStamp && shouldAllowMouseDown(ev);
    }
  }, {
    key: "shouldAllowTap",
    value: function shouldAllowTap(ev) {
      var type = ev.type,
          timeStamp = ev.timeStamp; // Allow the custom tap event for a “click” when it’s actually a click and it’s not from the
      // last mouseup event which would have fired the click for us

      return type === 'click' && this.lastMouseUpTime !== timeStamp;
    }
  }]);

  return ClickAllow;
}();

exports.ClickAllow = ClickAllow;
var _default = ClickAllow;
exports["default"] = _default;