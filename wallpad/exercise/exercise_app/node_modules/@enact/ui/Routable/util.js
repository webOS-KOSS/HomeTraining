"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toSegments = exports.stringifyRoutes = exports.resolve = exports.propTypes = exports.RouteContext = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = require("react");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var RouteContext = /*#__PURE__*/(0, _react.createContext)(null);
exports.RouteContext = RouteContext;

var toSegments = function toSegments(path) {
  return Array.isArray(path) ? path : (path || '').split('/').filter(Boolean);
};

exports.toSegments = toSegments;

var getPaths = function getPaths(routes, base) {
  var result = [];
  Object.keys(routes).filter(function (s) {
    return s[0] !== '$';
  }).forEach(function (p) {
    var path = base + '/' + p;
    result.push(path);
    result = result.concat(getPaths(routes[p], path));
  });
  return result;
};

var stringifyRoutes = function stringifyRoutes(routes) {
  var pad = '\n\t';
  var paths = getPaths(routes, '');
  return pad + paths.join(pad);
}; // resolves path relative to base


exports.stringifyRoutes = stringifyRoutes;

var resolve = function resolve() {
  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';
  var path = arguments.length > 1 ? arguments[1] : undefined;
  // We could resolve to base but we want to consider this an error condition
  if (!path) return; // convert a base array to a string for simpler normalization

  if (base instanceof Array) base = base.join('/'); // normalize base to have a leading slash

  if (!base.startsWith('/')) base = '/' + base; // if path has a leading slash, it's an absolute path so return it

  if (path.startsWith('/')) return path; // if path isn't absolute and doesn't begin with ., it's relative to the base

  if (!path.startsWith('.')) return base + '/' + path; // convert to arrays remove empty paths from base

  base = base.split('/').filter(Boolean);
  path = path.split('/');

  while (path.length > 0) {
    var p = path.shift();

    if (!p || p === '.') {
      // if we have an empty path or a current directory path, continue
      continue;
    } else if (p === '..') {
      // if we're down the root and we encounter a parent path, return
      if (base.length === 0) return; // otherwise, remove a level from base

      base.pop();
    } else {
      // put back the current element so it can be included in the output path
      path.unshift(p);
      break;
    }
  } // finally rebuild the path including the segment we just shifted


  return "/".concat(base.concat(path).join('/'));
};

exports.resolve = resolve;
var propTypes = {
  path: _propTypes["default"].oneOfType([_propTypes["default"].arrayOf(_propTypes["default"].string), // array of path segments
  _propTypes["default"].string // URI-style path
  ])
};
exports.propTypes = propTypes;