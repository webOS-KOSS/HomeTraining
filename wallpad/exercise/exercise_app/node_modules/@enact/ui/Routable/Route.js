"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.Route = void 0;

var _propTypes = _interopRequireDefault(require("@enact/core/internal/prop-types"));

var _propTypes2 = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Used with {@link ui/Routable.Routable} to define the `path` segment and the
 * `component` to render.
 *
 *`Route` elements can be nested to build multiple level paths.
 *
 * In the below example, `Panels` would render `SettingsPanel` with breadcrumbs to
 * navigate `AppPanel` and `HomePanel`.
 *
 * Example:
 * ```
 *	<Panels path="/app/home/settings" onSelectBreadcrumb={this.handleNavigate}>
 *		<Route path="app" component={AppPanel}>
 *			<Route path="home" component={HomePanel}>
 *				<Route path="settings" component={SettingsPanel} />
 *			</Route>
 *		</Route>
 *		<Route path="admin" component={AdminPanel} />
 *		<Route path="help" component={HelpPanel} />
 *	</Panels>
 * ```
 *
 * @class Route
 * @ui
 * @memberof ui/Routable
 * @public
 */
var Route = function Route() {
  return null;
};

exports.Route = Route;
Route.propTypes = {
  /**
   * The component to render when the `path` for this Route matches the path of the
   * {@link ui/Routable.Routable} container.
   *
   * @type {String|Component}
   * @required
   * @public
   * @memberof ui/Routable.Route.prototype
   */
  component: _propTypes["default"].renderable.isRequired,

  /**
   * The name of the path segment.
   *
   * @type {String}
   * @required
   * @public
   * @memberof ui/Routable.Route.prototype
   */
  path: _propTypes2["default"].string.isRequired
};
var _default = Route;
exports["default"] = _default;