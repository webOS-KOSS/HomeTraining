"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shape = exports.arrange = exports.SlideTopArranger = exports.SlideRightArranger = exports.SlideLeftArranger = exports.SlideBottomArranger = exports.SlideArranger = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var slideInOut = function slideInOut(direction, total, orientation) {
  var p = direction === 'out' ? total : -total;
  return orientation === 'top' && 'translateY(' + -p + '%)' || orientation === 'bottom' && 'translateY(' + p + '%)' || orientation === 'left' && 'translateX(' + -p + '%)' || orientation === 'right' && 'translateX(' + p + '%)';
};

var arrange = function arrange(_ref, keyframes, options) {
  var duration = _ref.duration,
      node = _ref.node,
      reverse = _ref.reverse;
  return node.animate(keyframes, _objectSpread({
    duration: duration,
    direction: reverse ? 'reverse' : 'normal',
    fill: 'forwards'
  }, options));
};
/**
 * A function that generates an animation for a given transition configuration
 *
 * @callback ArrangerCallback
 * @param {Object} config                                      - Animation configuration object.
 * @param {Number} config.duration                             - Duration of the animation in ms.
 * @param {('forwards'|'backwards'|'both'|'none')} config.fill - Animation effect should be
 *                                                               reflected by previous state or
 *                                                               retained after animation.
 * @param {Number} config.from                                 - Index from which the ViewManager is
 *                                                               transitioning.
 * @param {Node} config.node                                   - DOM node to be animated.
 * @param {Boolean} config.reverse                             - `true` when the animation should be
 *                                                               reversed.
 * @param {Boolean} config.rtl                                 - `true` when the ViewManager was
 *                                                                configured with `rtl` for locales
 *                                                                that use right-to-left reading
 *                                                                order.
 * @param {Number} config.to                                   - Index to which the ViewManager is
 *                                                               transitioning.
 * @returns {Animation} An `Animation`-compatible object
 * @public
 * @memberof ui/ViewManager
 */

/**
 * An object with callback functions to arrange views within {@link ui/ViewManager.ViewManager}.
 *
 * @typedef {Object} Arranger
 * @property {ArrangerCallback} enter  - Returns an array of keyframes describing the animation when
 *                                       a view is entering the viewport.
 * @property {ArrangerCallback} leave  - Returns an array of keyframes describing the animation when
 *                                       a view is leaving the viewport.
 * @property {ArrangerCallback} [stay] - Returns an array of keyframes describing the animation when
 *                                       a view is remaining in the viewport.
 * @public
 * @memberof ui/ViewManager
 */

/**
 * A basic arranger factory that must be configured with `direction` and optionally an `amount`.
 *
 * @function
 * @memberof ui/ViewManager
 * @param {Object}                          config              - Configuration object.
 * @param {Object}                          [config.amount=100] - Amount, as a whole number, to
 *                                                                "slide" where 100 is the entire
 *                                                                size of the node along the axis of
 *                                                                the `direction`.
 * @param {('bottom'|'left'|'right'|'top')} config.direction    - Direction from which the view will
 *                                                                transition.
 * @returns {Arranger}            An arranger
 * @public
 */


exports.arrange = arrange;

var SlideArranger = function SlideArranger(_ref2) {
  var _ref2$amount = _ref2.amount,
      amount = _ref2$amount === void 0 ? 100 : _ref2$amount,
      direction = _ref2.direction;
  return {
    enter: function enter(config) {
      return arrange(config, [{
        transform: slideInOut('in', amount, direction)
      }, {
        transform: slideInOut('in', 0, direction)
      }]);
    },
    leave: function leave(config) {
      return arrange(config, [{
        transform: slideInOut('out', 0, direction)
      }, {
        transform: slideInOut('out', amount, direction)
      }]);
    },
    stay: function stay(config) {
      return arrange(config, [{
        transform: slideInOut('in', 0, direction)
      }, {
        transform: slideInOut('in', 0, direction)
      }]);
    }
  };
};
/**
 * An arranger that enters from the left and leaves to the right.
 *
 * @type {Arranger}
 * @memberof ui/ViewManager
 * @public
 */


exports.SlideArranger = SlideArranger;
var SlideRightArranger = SlideArranger({
  direction: 'right'
});
/**
 * An arranger that enters from the right and leaves to the left..
 *
 * @type {Arranger}
 * @memberof ui/ViewManager
 * @public
 */

exports.SlideRightArranger = SlideRightArranger;
var SlideLeftArranger = SlideArranger({
  direction: 'left'
});
/**
 * An arranger that enters from the bottom and leaves to the top..
 *
 * @type {Arranger}
 * @memberof ui/ViewManager
 * @public
 */

exports.SlideLeftArranger = SlideLeftArranger;
var SlideTopArranger = SlideArranger({
  direction: 'top'
});
/**
 * An arranger that enters from the top and leaves to the bottom..
 *
 * @type {Arranger}
 * @memberof ui/ViewManager
 * @public
 */

exports.SlideTopArranger = SlideTopArranger;
var SlideBottomArranger = SlideArranger({
  direction: 'bottom'
});
/**
 * propType validation for Arranger transitions
 * @memberof ui/ViewManager
 * @private
 */

exports.SlideBottomArranger = SlideBottomArranger;

var shape = _propTypes["default"].shape({
  enter: _propTypes["default"].func,
  leave: _propTypes["default"].func
});

exports.shape = shape;