"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.IconDecorator = exports.IconBase = exports.Icon = void 0;

var _kind = _interopRequireDefault(require("@enact/core/kind"));

var _propTypes = _interopRequireDefault(require("@enact/core/internal/prop-types"));

var _util = require("@enact/core/util");

var _propTypes2 = _interopRequireDefault(require("prop-types"));

var _compose = _interopRequireDefault(require("ramda/src/compose"));

var _resolution = _interopRequireDefault(require("../resolution"));

var _ForwardRef = _interopRequireDefault(require("../ForwardRef"));

var _IconModule = _interopRequireDefault(require("./Icon.module.css"));

var _jsxRuntime = require("react/jsx-runtime");

var _excluded = ["componentRef", "iconProps"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * Merges consumer styles with the image `src` resolved through the resolution independence module.
 *
 * @function
 * @param	{Object}		style	Style object
 * @param	{String|Object}	src		URI to image or object of URIs
 *
 * @returns	{Object}				Original style object with backgroundImage updated
 * @private
 */
var mergeStyle = function mergeStyle(style, src) {
  var updated = Object.assign({}, style);

  var source = _resolution["default"].selectSrc(src);

  if (src && src !== 'none' && src !== 'inherit' && src !== 'initial') {
    source = "url(".concat(source, ")");
  }

  updated.backgroundImage = source;
  return updated;
};
/**
 * Tests if a string appears to be a URI/URL.
 *
 * @function
 * @param	{String}	c	Character to test
 *
 * @returns	{Boolean}		`true` if c looks like a URL
 * @private
 */


var isUri = function isUri(c) {
  return c.indexOf('/') > -1 || c.indexOf('.') > -1;
};
/**
 * A basic icon component structure without any behaviors applied to it.
 *
 * @class IconBase
 * @memberof ui/Icon
 * @ui
 * @public
 */


var IconBase = (0, _kind["default"])({
  name: 'ui:Icon',
  propTypes:
  /** @lends ui/Icon.IconBase.prototype */
  {
    /**
     * The icon content.
     *
     * May be specified as either:
     *
     * * A string that represents an icon from the [iconList]{@link ui/Icon.IconBase.iconList},
     * * An HTML entity string, Unicode reference or hex value (in the form '0x...'),
     * * A URL specifying path to an icon image, or
     * * An object representing a resolution independent resource (See {@link ui/resolution}).
     *
     * @type {String|Object}
     * @public
     */
    children: _propTypes2["default"].oneOfType([_propTypes2["default"].string, _propTypes2["default"].object]),

    /**
     * Called with a reference to the root component.
     *
     * When using {@link ui/Icon.Icon}, the `ref` prop is forwarded to this component
     * as `componentRef`.
     *
     * @type {Object|Function}
     * @public
     */
    componentRef: _propTypes["default"].ref,

    /**
     * Customizes the component by mapping the supplied collection of CSS class names to the
     * corresponding internal elements and states of this component.
     *
     * The following classes are supported:
     *
     * * `icon` - The root component class
     * * `dingbat` - Applied when the value of [`icon`]{@link ui/Icon.IconBase.icon} is not
     *   found in [iconList]{@link ui/Icon.IconBase.iconList}
     * * `large` - Applied when `size` prop is `'large'`
     * * `pressed` - Applied when `pressed` prop is `true`
     * * `small` - Applied when `size` prop is `'small'`
     *
     * @type {Object}
     * @public
     */
    css: _propTypes2["default"].object,

    /**
     * Flip the icon horizontally, vertically or both.
     *
     * @type {('both'|'horizontal'|'vertical')}
     * @public
     */
    flip: _propTypes2["default"].string,

    /**
     * The full list (hash) of supported icons.
     *
     * The keys of this hash are the unique names of each icon. The values are the unicode
     * characters to insert in the icon. These will typically map to glyphs in your icon-font.
     * The format of the keys can be character, glyph, or entity reference that correctly
     * renders in a React + JSX string.
     *
     * @type {Object}
     * @default {}
     * @public
     */
    iconList: _propTypes2["default"].object,

    /**
     * Applies the `pressed` CSS class.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    pressed: _propTypes2["default"].bool,

    /**
     * The size of the button.
     *
     * Applies the CSS class which can be customized by
     * [theming]{@link /docs/developer-guide/theming/}.
     *
     * @type {String}
     * @public
     */
    size: _propTypes2["default"].string
  },
  defaultProps: {
    iconList: {},
    pressed: false
  },
  styles: {
    css: _IconModule["default"],
    className: 'icon',
    publicClassNames: true
  },
  computed: {
    className: function className(_ref) {
      var icon = _ref.children,
          flip = _ref.flip,
          iconList = _ref.iconList,
          pressed = _ref.pressed,
          size = _ref.size,
          styler = _ref.styler;
      return styler.append({
        // If the icon isn't in our known set, apply our custom font class
        dingbat: !(icon in iconList),
        pressed: pressed
      }, flip ? "flip".concat((0, _util.cap)(flip)) : null, size);
    },
    iconProps: function iconProps(_ref2) {
      var iconProp = _ref2.children,
          iconList = _ref2.iconList,
          style = _ref2.style;
      var icon = iconList[iconProp];

      if (!icon) {
        if (typeof iconProp == 'string') {
          if (iconProp.indexOf('&#x') === 0) {
            // Converts a hex reference in HTML entity form: &#x99999;
            icon = parseInt(iconProp.slice(3, -1), 16);
          } else if (iconProp.indexOf('&#') === 0) {
            // Convert an HTML entity: &#99999;
            icon = parseInt(iconProp.slice(2, -1));
          } else if (iconProp.indexOf("\\u") === 0) {
            // Convert a unicode reference: \u99999;
            icon = parseInt(iconProp.slice(2), 16);
          } else if (iconProp.indexOf('0x') === 0) {
            // Converts a hex reference in string form
            icon = String.fromCodePoint(iconProp);
          } else if (!isUri(iconProp)) {
            // A "simple" string is assumed to be an icon-name string
            icon = iconProp;
          } else {
            // for a path or URI, add it to style
            style = mergeStyle(style, iconProp);
          }
        } else if (typeof iconProp === 'object') {
          style = mergeStyle(style, iconProp);
        }
      }

      if (typeof icon == 'number') {
        // Converts a hex reference in number form
        icon = String.fromCodePoint(icon);
      }

      return {
        children: icon,
        style: style
      };
    }
  },
  render: function render(_ref3) {
    var componentRef = _ref3.componentRef,
        iconProps = _ref3.iconProps,
        rest = _objectWithoutProperties(_ref3, _excluded);

    delete rest.iconList;
    delete rest.pressed;
    delete rest.size;
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", _objectSpread(_objectSpread(_objectSpread({
      "aria-hidden": true
    }, rest), iconProps), {}, {
      ref: componentRef
    }));
  }
});
/**
 * A higher-order component that adds behavior to [Icon]{@link ui/Icon.IconBase}.
 *
 * @hoc
 * @memberof ui/Icon
 * @mixes ui/ForwardRef.ForwardRef
 * @public
 */

exports.IconBase = IconBase;
var IconDecorator = (0, _compose["default"])((0, _ForwardRef["default"])({
  prop: 'componentRef'
}));
/**
 * An Icon component.
 *
 * @class Icon
 * @extends ui/Icon.IconBase
 * @mixes ui/Icon.IconDecorator
 * @omit componentRef
 * @memberof ui/Icon
 * @ui
 * @public
 */

exports.IconDecorator = IconDecorator;
var Icon = IconDecorator(IconBase);
exports.Icon = Icon;
var _default = Icon;
exports["default"] = _default;