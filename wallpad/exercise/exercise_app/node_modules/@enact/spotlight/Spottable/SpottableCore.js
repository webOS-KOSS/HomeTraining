"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spottableClass = exports["default"] = exports.SpottableCore = void 0;

var _handle = require("@enact/core/handle");

var _keymap = require("@enact/core/keymap");

var _container = require("../src/container");

var _spotlight = require("../src/spotlight");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var REMOTE_OK_KEY = 16777221;
/**
 * The class name for spottable components. In general, you do not need to directly access this class
 *
 * @memberof spotlight/Spottable
 * @public
 */

var spottableClass = 'spottable';
exports.spottableClass = spottableClass;

var isKeyboardAccessible = function isKeyboardAccessible(node) {
  if (!node) return false;
  var name = node.nodeName.toUpperCase();
  var type = node.type ? node.type.toUpperCase() : null;
  return name === 'BUTTON' || name === 'A' || name === 'INPUT' && (type === 'BUTTON' || type === 'CHECKBOX' || type === 'IMAGE' || type === 'RADIO' || type === 'RESET' || type === 'SUBMIT');
};

var isSpottable = function isSpottable(props) {
  return !props.spotlightDisabled;
}; // Last instance of spottable to be focused


var lastSelectTarget = null; // Should we prevent select being passed through

var selectCancelled = false;

var SpottableCore = /*#__PURE__*/function () {
  function SpottableCore(_ref) {
    var _this = this;

    var emulateMouse = _ref.emulateMouse;

    _classCallCheck(this, SpottableCore);

    this.didUpdate = function () {
      _this.isFocused = _this.node && _this.node === _spotlight.Spotlight.getCurrent(); // if the component is focused and became disabled

      if (_this.isFocused && _this.props.disabled && lastSelectTarget === _this && !selectCancelled) {
        selectCancelled = true;
        (0, _handle.forwardCustom)('onSelectionCancel')(null, _this.props);
      } // if the component became enabled, notify spotlight to enable restoring "lost" focus


      if (isSpottable(_this.props) && _this.context.prevSpotlightDisabled && !_spotlight.Spotlight.isPaused()) {
        if (_spotlight.Spotlight.getPointerMode()) {
          if (_this.isHovered) {
            _spotlight.Spotlight.setPointerMode(false);

            _spotlight.Spotlight.focus(_this.node);

            _spotlight.Spotlight.setPointerMode(true);
          }
        } else if (!_spotlight.Spotlight.getCurrent()) {
          var containers = (0, _container.getContainersForNode)(_this.node);

          var containerId = _spotlight.Spotlight.getActiveContainer();

          if (containers.indexOf(containerId) >= 0) {
            _spotlight.Spotlight.focus(containerId);
          }
        }
      }
    };

    this.forwardSpotlightEvents = function (ev, _ref2) {
      var onSpotlightDown = _ref2.onSpotlightDown,
          onSpotlightLeft = _ref2.onSpotlightLeft,
          onSpotlightRight = _ref2.onSpotlightRight,
          onSpotlightUp = _ref2.onSpotlightUp;
      var keyCode = ev.keyCode;

      if (onSpotlightDown && (0, _keymap.is)('down', keyCode)) {
        onSpotlightDown(ev);
      } else if (onSpotlightLeft && (0, _keymap.is)('left', keyCode)) {
        onSpotlightLeft(ev);
      } else if (onSpotlightRight && (0, _keymap.is)('right', keyCode)) {
        onSpotlightRight(ev);
      } else if (onSpotlightUp && (0, _keymap.is)('up', keyCode)) {
        onSpotlightUp(ev);
      }

      return true;
    };

    this.forwardAndResetLastSelectTarget = function (ev, props) {
      var keyCode = ev.keyCode;
      var selectionKeys = props.selectionKeys;
      var key = selectionKeys.find(function (value) {
        return keyCode === value;
      });
      var notPrevented = !ev.defaultPrevented; // bail early for non-selection keyup to avoid clearing lastSelectTarget prematurely

      if (!key && (!(0, _keymap.is)('enter', keyCode) || !(0, _spotlight.getDirection)(keyCode))) {
        return notPrevented;
      }

      var allow = lastSelectTarget === _this;
      selectCancelled = false;
      lastSelectTarget = null;
      return notPrevented && allow;
    };

    this.shouldEmulateMouse = function (ev, props) {
      if (!_this.config.emulateMouse) {
        return;
      }

      var currentTarget = ev.currentTarget,
          repeat = ev.repeat,
          type = ev.type,
          which = ev.which;
      var selectionKeys = props.selectionKeys;
      var keyboardAccessible = isKeyboardAccessible(currentTarget);
      var keyCode = selectionKeys.find(function (value) {
        return (// emulate mouse events for any remote okay button event
          which === REMOTE_OK_KEY || // or a non-keypress selection event or any selection event on a non-keyboard accessible
          // control
          which === value && (type !== 'keypress' || !keyboardAccessible)
        );
      });

      if ((0, _spotlight.getDirection)(keyCode)) {
        (0, _handle.preventDefault)(ev);
        (0, _handle.stop)(ev);
      } else if (keyCode && keyboardAccessible) {
        (0, _handle.preventDefault)(ev);
      }

      return keyCode && !repeat;
    };

    this.isActionable = function (ev, props) {
      return isSpottable(props);
    };

    this.handleSelect = function (_ref3, props) {
      var which = _ref3.which;
      var selectionKeys = props.selectionKeys; // Only apply accelerator if handling a selection key

      if (selectionKeys.find(function (value) {
        return which === value;
      })) {
        if (selectCancelled || lastSelectTarget && lastSelectTarget !== _this) {
          return false;
        }

        lastSelectTarget = _this;
      }

      return true;
    };

    this.handle = _handle.handle.bind(this);
    this.handleKeyDown = this.handle(function (ev) {
      return !ev.defaultPrevented;
    }, this.forwardSpotlightEvents, this.isActionable, this.handleSelect, this.shouldEmulateMouse // `forwardMouseDown` is usually called out of the useSpottable if the `this.shouldEmulateMouse` returns true.
    );
    this.handleKeyUp = this.handle(this.forwardAndResetLastSelectTarget, this.isActionable, this.shouldEmulateMouse // `forwardMouseUp` and `forwardClick` are usually called out of the useSpottable if the `this.shouldEmulateMouse` returns true.
    );

    this.handleFocus = function (ev) {
      if (_this.props.spotlightDisabled) {
        _this.shouldPreventBlur = true;
        ev.target.blur();
        _this.shouldPreventBlur = false;
        return;
      }

      if (ev.currentTarget === ev.target) {
        _this.isFocused = true;
      }

      if (_spotlight.Spotlight.isMuted(ev.target)) {
        ev.stopPropagation();
        return false;
      }

      return true;
    };

    this.handleBlur = function (ev) {
      if (_this.shouldPreventBlur) return false;

      if (ev.currentTarget === ev.target) {
        _this.isFocused = false;

        if (_this.isFocusedWhenDisabled) {
          _this.isFocusedWhenDisabled = false; // We only need to trigger a rerender if a focused item becomes disabled and still needs its focus.
          // Once it blurs we need to rerender to remove the spottable class so it will not spot again.
          // The reason we don't use state is for performance reasons to avoid updates.

          _this.props.handleForceUpdate();
        }
      }

      if (_spotlight.Spotlight.isMuted(ev.target)) {
        ev.stopPropagation();
        return false;
      }

      return true;
    };

    this.handleEnter = function () {
      _this.isHovered = true;
    };

    this.handleLeave = function () {
      _this.isHovered = false;
    };

    this.config = {
      emulateMouse: emulateMouse
    };
    this.props = {};
    this.context = {};
    this.isFocused = false;
    this.isFocusedWhenDisabled = false;
    this.isHovered = false;
    this.spottableClass = null; // Used to indicate that we want to stop propagation on blur events that occur as a
    // result of this component imperatively blurring itself on focus when spotlightDisabled

    this.shouldPreventBlur = false;
  }

  _createClass(SpottableCore, [{
    key: "setPropsAndContext",
    value: function setPropsAndContext(props, context) {
      this.props = props;
      this.context.prevSpotlightDisabled = context.prevSpotlightDisabled;
      this.isFocusedWhenDisabled = this.isFocused && props.spotlightDisabled;
      this.spottableClass = this.isFocusedWhenDisabled || isSpottable(props) ? spottableClass : null;
    }
  }, {
    key: "load",
    value: function load() {
      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.node = node;
    }
  }, {
    key: "unload",
    value: function unload() {
      if (this.isFocused) {
        (0, _handle.forwardCustom)('onSpotlightDisappear')(null, this.props);
      }

      if (lastSelectTarget === this) {
        lastSelectTarget = null;
      }
    }
  }]);

  return SpottableCore;
}();

exports.SpottableCore = SpottableCore;
var _default = SpottableCore;
exports["default"] = _default;