"use strict";

require("@testing-library/jest-dom");

var _react = require("@testing-library/react");

var _userEvent = _interopRequireDefault(require("@testing-library/user-event"));

var _SpotlightContainerDecorator = _interopRequireDefault(require("../SpotlightContainerDecorator"));

var _pointer = require("../../src/pointer");

var _spotlight = _interopRequireDefault(require("../../src/spotlight"));

var _ElementPrototype = _interopRequireDefault(require("./Element.prototype.closest"));

var _jsxRuntime = require("react/jsx-runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var testId = 'test-spotlightContainerDecorator';
describe('SpotlightContainerDecorator', function () {
  var hoverPosition = {
    clientX: 0,
    clientY: 1
  };
  var unhoverPosition = {
    clientX: 0,
    clientY: 0
  };

  var Div = function Div(props) {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", _objectSpread({}, props));
  };

  (0, _ElementPrototype["default"])(beforeAll, afterAll);
  beforeEach(function () {
    _spotlight["default"].setActiveContainer(null);

    (0, _pointer.updatePointerPosition)(0, 0);
  });
  test('should set itself as the active container on mouse enter', function () {
    var Component = (0, _SpotlightContainerDecorator["default"])(Div);
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      "data-testid": testId,
      spotlightId: "test-container"
    }));

    var component = _react.screen.getByTestId(testId);

    _userEvent["default"].hover(component, hoverPosition);

    var expected = 'test-container';

    var actual = _spotlight["default"].getActiveContainer();

    expect(actual).toBe(expected);
  });
  test('should set active container to parent container on mouse leave', function () {
    var Component = (0, _SpotlightContainerDecorator["default"])(Div);
    var node = document.createElement('div');
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      spotlightId: "outer-container",
      children: /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
        "data-testid": testId,
        spotlightId: "inner-container"
      })
    }), {
      attachTo: node
    });

    var component = _react.screen.getByTestId(testId); // set inner-container as active


    _userEvent["default"].hover(component, hoverPosition);

    (0, _pointer.updatePointerPosition)(0, 1); // leave inner-container

    _userEvent["default"].unhover(component, unhoverPosition);

    var expected = 'outer-container';

    var actual = _spotlight["default"].getActiveContainer();

    expect(actual).toBe(expected);
  });
  test('should not set active container on mouse leave if another container is active', function () {
    var Component = (0, _SpotlightContainerDecorator["default"])(Div);
    var node = document.createElement('div');
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsxs)(Component, {
      spotlightId: "outer-container",
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
        "data-testid": testId,
        spotlightId: "inner-container"
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
        spotlightId: "self-only-container"
      })]
    }), {
      attachTo: node
    });

    var component = _react.screen.getByTestId(testId); // set inner-container as active


    _userEvent["default"].hover(component, hoverPosition);

    (0, _pointer.updatePointerPosition)(0, 1); // set another container to be active

    _spotlight["default"].setActiveContainer('self-only-container'); // leave inner-container


    _userEvent["default"].unhover(component, unhoverPosition);

    var expected = 'self-only-container';

    var actual = _spotlight["default"].getActiveContainer();

    expect(actual).toBe(expected);
  });
  test('should forward onFocusCapture events', function () {
    var spy = jest.fn();
    var focus;
    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref) {
      var onFocusCapture = _ref.onFocusCapture;
      focus = onFocusCapture;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {});
    });
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onFocusCapture: spy
    }));
    focus({});
    var expected = 1;
    expect(spy).toHaveBeenCalledTimes(expected);
  });
  test('should suppress onFocusCapture events when spotlightDisabled', function () {
    var spy = jest.fn();
    var focus;
    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref2) {
      var onFocusCapture = _ref2.onFocusCapture;
      focus = onFocusCapture;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {});
    });
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onFocusCapture: spy,
      spotlightDisabled: true
    })); // building out the api called on the event object + target

    focus({
      stopPropagation: function stopPropagation() {
        return true;
      },
      target: {
        blur: function blur() {
          return true;
        }
      }
    });
    expect(spy).not.toHaveBeenCalled();
  });
  test('should forward onBlurCapture events', function () {
    var spy = jest.fn();

    var _blur;

    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref3) {
      var onBlurCapture = _ref3.onBlurCapture;
      _blur = onBlurCapture;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {});
    });
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onBlurCapture: spy,
      spotlightDisabled: true
    })); // building out the api called on the event object + target

    _blur({
      stopPropagation: function stopPropagation() {
        return true;
      },
      target: {
        blur: function blur() {
          return _blur({});
        }
      }
    });

    var expected = 1;
    expect(spy).toHaveBeenCalledTimes(expected);
  });
  test('should suppress onBlurCapture events when focus was suppressed', function () {
    var spy = jest.fn();

    var _blur2;

    var focus;
    var Component = (0, _SpotlightContainerDecorator["default"])(function (_ref4) {
      var onBlurCapture = _ref4.onBlurCapture,
          onFocusCapture = _ref4.onFocusCapture;
      _blur2 = onBlurCapture;
      focus = onFocusCapture;
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {});
    });
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onBlurCapture: spy,
      spotlightDisabled: true
    })); // building out the api called on the event object + target

    focus({
      stopPropagation: function stopPropagation() {
        return true;
      },
      target: {
        // the focus handler calls blur() on the target so we're simulating that here by
        // wiring our onBlurCapture handler directly to the invocation. This isn't a
        // perfect modeling of the system but serves to validate the callback
        // suppression logic.
        blur: function blur() {
          return _blur2({});
        }
      }
    });
    expect(spy).not.toHaveBeenCalled();
  });
});