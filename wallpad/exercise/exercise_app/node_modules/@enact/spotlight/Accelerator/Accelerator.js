"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.Accelerator = void 0;

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Provides the {@link spotlight/Accelerator.Accelerator} class.
 *
 * @module spotlight/Accelerator
 * @exports Accelerator
 */

/**
 * @class Accelerator
 * @memberof spotlight/Accelerator
 */
var Accelerator = /*#__PURE__*/_createClass(
/**
 * @constructor
 * @param {Number[]} frequency - Controls the frequency with which the acceleration will
 *	"freeze". While frozen, the current target item cannot change, and all events are directed
 *	to it.
 * @memberof spotlight/Accelerator.Accelerator.prototype
 */
function Accelerator() {
  var _this = this;

  var frequency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [3, 3, 3, 2, 2, 2, 1];

  _classCallCheck(this, Accelerator);

  this.processKey = function (event, callback) {
    switch (event.type) {
      case 'keydown':
        if (event.keyCode !== _this.keyCode) {
          _this.reset();

          _this.time = Date.now();
          _this.keyCode = event.keyCode;
          return callback(event);
        } else if (_this.canceled) {
          // Prevent skipped keydown events from bubbling
          event.preventDefault();
          return true;
        } else {
          var elapsedTime = Date.now() - _this.time,
              seconds = Math.floor(elapsedTime / 1000),
              toSkip = 0;

          seconds = seconds > _this.frequency.length - 1 ? _this.frequency.length - 1 : seconds;
          toSkip = _this.frequency[seconds] - 1;

          if (toSkip < 0) {
            toSkip = 0;
          }

          _this.accelerating = !(seconds === 0 && _this.skipped === 0);

          if (_this.skipped >= toSkip) {
            _this.skipped = 0;
            return callback(event);
          } else {
            _this.skipped++; // Prevent skipped keydown events from bubbling

            event.preventDefault();
            return true;
          }
        }

      case 'keyup':
        _this.reset();

        return callback(event);
    }
  };

  this.reset = function () {
    _this.skipped = 0;
    _this.time = 0;
    _this.keyCode = 0;
    _this.canceled = false;
    _this.accelerating = false;
  };

  this.cancel = function () {
    _this.canceled = true;
  };

  this.isAccelerating = function () {
    return _this.accelerating;
  };

  /*
   * Whether the instance is currently in an accelerating state.
   *
   * @type {Boolean}
   * @default false
   */
  this.accelerating = false;
  /*
   * The current count of skipped events.
   *
   * @type {Number}
   * @default 0
   */

  this.skipped = 0;
  /*
   * The timestamp of the last evaluated event.
   *
   * @type {Number}
   * @default 0
   */

  this.time = 0;
  /*
   * The keyCode of the last evaluated event.
   *
   * @type {Number}
   * @default 0
   */

  this.keyCode = 0;
  /*
   * Whether the instance is in a state of being canceled.
   *
   * @type {Boolean}
   * @default false
   */

  this.canceled = false;
  /*
   * Controls the frequency with which the acceleration will "freeze". While frozen,
   * the current target item cannot change, and all events are directed to it.
   *
   * @type {Number[]}
   * @default [3, 3, 3, 2, 2, 2, 1]
   * @public
   */

  this.frequency = frequency;
}
/**
 * Called with the current keydown event and callback, which will be called when the event is
 * allowed through.
 *
 * @function
 * @param  {Object} event - The current event to validate.
 * @param  {Function} callback - The callback to execute.
 * @returns {Boolean} `true` if the event was consumed by processKey and callback was not called
 * @public
 * @memberof spotlight/Accelerator.Accelerator.prototype
 */
);

exports.Accelerator = Accelerator;
var _default = Accelerator;
exports["default"] = _default;