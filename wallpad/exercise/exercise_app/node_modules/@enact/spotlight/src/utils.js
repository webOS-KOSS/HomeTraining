"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.contains = void 0;
exports.getContainerRect = getContainerRect;
exports.getPointRect = getPointRect;
exports.getRect = getRect;
exports.getRects = getRects;
exports.matchSelector = exports.intersects = void 0;
exports.parseSelector = parseSelector;

var _curry = _interopRequireDefault(require("ramda/src/curry"));

var _warning = _interopRequireDefault(require("warning"));

var _container = require("./container");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var elementMatchesSelector = function elementMatchesSelector(selector) {
  var matchedNodes = (this.parentNode || this.document).querySelectorAll(selector);
  return [].slice.call(matchedNodes).indexOf(this) >= 0;
};

if (typeof window === 'object') {
  elementMatchesSelector = window.Element.prototype.matches || window.Element.prototype.matchesSelector || window.Element.prototype.mozMatchesSelector || window.Element.prototype.webkitMatchesSelector || window.Element.prototype.msMatchesSelector || window.Element.prototype.oMatchesSelector || elementMatchesSelector;
}

var matchSelector = (0, _curry["default"])(function (selector, elem) {
  if (typeof selector === 'string') {
    return elementMatchesSelector.call(elem, selector);
  } else if (typeof selector === 'object' && selector.length) {
    return selector.indexOf(elem) >= 0;
  } else if (typeof selector === 'object' && selector.nodeType === 1) {
    return elem === selector;
  }

  return false;
});
exports.matchSelector = matchSelector;

function parseSelector(selector) {
  var result = [];

  try {
    if (typeof selector === 'string') {
      result = [].slice.call(document.querySelectorAll(selector));
    } else if (typeof selector === 'object' && selector.length) {
      result = [].slice.call(selector);
    } else if (typeof selector === 'object' && selector.nodeType === 1) {
      result = [selector];
    }
  } catch (ex) {
    process.env.NODE_ENV !== "production" ? (0, _warning["default"])(true, "parseSelector failed for selector: ".concat(selector)) : void 0;
  }

  return result;
}

var testIntersection = function testIntersection(type, containerRect, elementRect) {
  var L = containerRect.left,
      R = containerRect.right,
      T = containerRect.top,
      B = containerRect.bottom;
  var l = elementRect.left,
      r = elementRect.right,
      t = elementRect.top,
      b = elementRect.bottom;

  if (type === 'intersects') {
    // Test intersection by eliminating the area of the element that is outside of the container
    return !(b < T || t > B || r < L || l > R);
  } else if (type === 'contains') {
    var epsilon = 1; // Test whether all bounds are within the container

    return r > L - epsilon && r < R + epsilon && // right
    l > L - epsilon && l < R + epsilon && // left
    t > T - epsilon && t < B + epsilon && // top
    b > T - epsilon && b < B + epsilon // bottom
    ;
  }

  return true;
};

var intersects = (0, _curry["default"])(function (containerRect, elementRect) {
  return testIntersection('intersects', containerRect, elementRect);
});
exports.intersects = intersects;
var contains = (0, _curry["default"])(function (containerRect, elementRect) {
  return testIntersection('contains', containerRect, elementRect);
});
exports.contains = contains;

function getRect(elem) {
  var cr = elem.getBoundingClientRect();
  var rect = {
    left: cr.left,
    top: cr.top,
    width: cr.width,
    height: cr.height
  };
  rect.element = elem;
  rect.right = rect.left + rect.width;
  rect.bottom = rect.top + rect.height;
  rect.center = {
    x: rect.left + Math.floor(rect.width / 2),
    y: rect.top + Math.floor(rect.height / 2)
  };
  rect.center.left = rect.center.right = rect.center.x;
  rect.center.top = rect.center.bottom = rect.center.y;
  return rect;
}

function getPointRect(position) {
  var x = position.x,
      y = position.y;
  return {
    left: x,
    top: y,
    width: 0,
    height: 0,
    right: x,
    bottom: y,
    center: {
      x: x,
      y: y,
      left: x,
      right: x,
      top: y,
      bottom: y
    }
  };
}

function getRects(candidates) {
  if (candidates && candidates.length > 0) {
    return candidates.map(getRect);
  }

  return [];
}

function getViewportRect() {
  var _window = window,
      width = _window.innerWidth,
      height = _window.innerHeight;
  var x = width / 2;
  var y = height / 2;
  return {
    left: 0,
    top: 0,
    width: width,
    height: height,
    right: width,
    bottom: height,
    center: {
      x: x,
      y: y,
      left: x,
      right: x,
      top: y,
      bottom: y
    }
  };
}

function getContainerRect(containerId) {
  var containerNode = (0, _container.getContainerNode)(containerId);

  if (!containerNode) {
    return null;
  }

  if (containerNode === document) {
    return getViewportRect();
  }

  return getRect(containerNode);
}