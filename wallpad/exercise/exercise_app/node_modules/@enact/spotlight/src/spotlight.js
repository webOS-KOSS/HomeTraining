"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDirection = exports["default"] = exports.Spotlight = void 0;

var _keymap = require("@enact/core/keymap");

var _snapshot = require("@enact/core/snapshot");

var _platform = _interopRequireDefault(require("@enact/core/platform"));

var _last = _interopRequireDefault(require("ramda/src/last"));

var _Accelerator = _interopRequireDefault(require("../Accelerator"));

var _Spottable = require("../Spottable");

var _Pause = require("../Pause");

var _utils = require("./utils");

var _container = require("./container");

var _pointer = require("./pointer");

var _target = require("./target");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*
 * A javascript-based implementation of Spatial Navigation.
 *
 * Copyright (c) 2016 Luke Chang.
 * https://github.com/luke-chang/js-spatial-navigation
 *
 * Licensed under the MPL license.
 */

/**
 * Exports the {@link spotlight.Spotlight} object used for controlling spotlight behavior and the
 * {@link spotlight.Spotlight.getDirection} function for mapping a keycode to a spotlight direction.
 *
 * The default export is {@link spotlight.Spotlight}.
 *
 * @module spotlight
 * @exports default Spotlight
 * @exports getDirection
 */
var isDown = (0, _keymap.is)('down');
var isEnter = (0, _keymap.is)('enter');
var isLeft = (0, _keymap.is)('left');
var isRight = (0, _keymap.is)('right');
var isUp = (0, _keymap.is)('up');
/**
 * Translates keyCodes into 5-way direction descriptions (e.g. `'down'`)
 *
 * @function
 * @memberof spotlight
 * @param {Number} keyCode - Key code to analyze
 * @returns {String|false} - One of `'up'`, `'down'`, `'left'`, `'right'` or `false` if not a direction key
 * @public
 */

var getDirection = function getDirection(keyCode) {
  return isDown(keyCode) && 'down' || isLeft(keyCode) && 'left' || isRight(keyCode) && 'right' || isUp(keyCode) && 'up';
};

exports.getDirection = getDirection;
var SpotlightAccelerator = new _Accelerator["default"]();
/**
 * Provides 5-way navigation and focus support
 *
 * ```
 * import Spotlight from '@enact/Spotlight';
 *
 * // get the currently focused component
 * const current = Spotlight.getCurrent();
 *
 * // focus an element by CSS selector
 * Spotlight.focus('.my-custom-class');
 *
 * // is `current` focusable?
 * const isFocused = Spotlight.isSpottable(current);
 * ```
 *
 * @type {Object}
 * @memberof spotlight
 * @public
 */

var Spotlight = function () {
  'use strict';
  /*
  /* private vars
  */

  var _initialized = false;
  var _duringFocusChange = false;
  /*
   * Whether a 5-way directional key is being held.
   *
   * @type {Boolean}
   * @default false
   */

  var _5WayKeyHold = false;
  /*
   * Whether to set focus during the next window focus event
   *
   * @type {Boolean}
   * @default false
   */

  var _spotOnWindowFocus = false;
  /*
   * `true` when a pointer move event occurs during a keypress. Used to short circuit key down
   * handling until the next keyup occurs.
   *
   * @type {Boolean}
   * @default false
   */

  var _pointerMoveDuringKeyPress = false;
  /*
  * protected methods
  */

  function preventDefault(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    return false;
  }

  function shouldPreventNavigation() {
    return (0, _Pause.isPaused)() || (0, _container.getAllContainerIds)().length === 0;
  }

  function _getCurrent() {
    if (!(0, _snapshot.isWindowReady)()) return;
    var activeElement = document.activeElement;

    if (activeElement && activeElement !== document.body) {
      return activeElement;
    }
  } // An extension point for updating pointer mode based on the current platform.
  // Currently only webOS


  function setPlatformPointerMode() {
    var palmSystem = window.PalmSystem;

    if (palmSystem && palmSystem.cursor) {
      (0, _pointer.setPointerMode)(palmSystem.cursor.visibility);
    }
  }

  function focusElement(elem, containerIds, fromPointer) {
    if (!elem) {
      return false;
    }

    if ((0, _pointer.getPointerMode)() && !fromPointer) {
      (0, _container.setContainerLastFocusedElement)(elem, containerIds);
      return false;
    }

    var currentFocusedElement = _getCurrent();

    if (elem === currentFocusedElement) {
      return true;
    }

    var focusOptions = (0, _container.isWithinOverflowContainer)(elem, containerIds) ? {
      preventScroll: true
    } : null;

    var silentFocus = function silentFocus() {
      elem.focus(focusOptions);
      focusChanged(elem, containerIds);
    };

    if (_duringFocusChange) {
      silentFocus();
      return true;
    }

    _duringFocusChange = true;

    if ((0, _Pause.isPaused)()) {
      silentFocus();
      _duringFocusChange = false;
      return true;
    }

    elem.focus(focusOptions);
    _duringFocusChange = false;
    focusChanged(elem, containerIds);
    return true;
  }

  function focusChanged(elem, containerIds) {
    if (!containerIds || !containerIds.length) {
      containerIds = (0, _container.getContainersForNode)(elem);
    }

    var containerId = (0, _last["default"])(containerIds);

    if (containerId) {
      (0, _container.setContainerLastFocusedElement)(elem, containerIds);
      (0, _container.setLastContainer)(containerId);
    }

    if (process.env.NODE_ENV !== "production") {
      assignFocusPreview(elem);
    }
  }

  function restoreFocus() {
    var lastContainerId = (0, _container.getLastContainer)();
    var next;

    if (lastContainerId) {
      var position = (0, _pointer.getLastPointerPosition)(); // walk up the chain of containers from the last to attempt to find a target

      next = (0, _container.getContainersForNode)((0, _container.getContainerNode)(lastContainerId)).reverse(); // only prepend last focused if it exists so that Spotlight.focus() doesn't receive
      // a falsy target

      var lastFocusedElement = (0, _container.getContainerLastFocusedElement)(lastContainerId);

      while ((0, _container.isContainer)(lastFocusedElement)) {
        var _getContainerConfig = (0, _container.getContainerConfig)(lastFocusedElement);

        lastFocusedElement = _getContainerConfig.lastFocusedElement;
      }

      var lastContainerNode = (0, _container.getContainerNode)(lastContainerId);

      if (!lastFocusedElement || lastContainerNode.getBoundingClientRect && lastFocusedElement.getBoundingClientRect && !(0, _utils.contains)(lastContainerNode.getBoundingClientRect(), lastFocusedElement.getBoundingClientRect())) {
        lastFocusedElement = (0, _container.getContainerConfig)(lastContainerId).overflow && (0, _target.getNearestTargetFromPosition)(position, lastContainerId);
      }

      if (lastFocusedElement) {
        next.unshift(lastFocusedElement);
      }
    } else {
      next = [_container.rootContainerId];
    } // attempt to find a target starting with the last focused element in the last
    // container, followed by the last container, and finally the root container


    return next.reduce(function (focused, target) {
      return focused || Spotlight.focus(target);
    }, false);
  } // The below should be gated on non-production environment only.


  function assignFocusPreview(elem) {
    var directions = ['up', 'right', 'down', 'left'],
        nextClassBase = _Spottable.spottableClass + '-next-'; // Remove all previous targets

    directions.forEach(function (dir) {
      var nextClass = nextClassBase + dir,
          prevElems = (0, _utils.parseSelector)('.' + nextClass);

      if (prevElems && prevElems.length !== 0) {
        prevElems.forEach(function (prevElem) {
          return prevElem.classList.remove(nextClass);
        });
      }
    }); // Find all next targets and identify them

    directions.forEach(function (dir) {
      var nextElem = (0, _target.getTargetByDirectionFromElement)(dir, elem);

      if (nextElem) {
        nextElem.classList.add(nextClassBase + dir);
      }
    });
  }

  function spotNextFromPoint(direction, position) {
    var containerId = Spotlight.getActiveContainer();
    var next = (0, _target.getTargetByDirectionFromPosition)(direction, position, containerId);

    if (next) {
      (0, _container.setContainerPreviousTarget)(containerId, direction, next, (0, _container.getContainerLastFocusedElement)(containerId));
      return focusElement(next, (0, _container.getContainersForNode)(next));
    }

    return false;
  }

  function spotNext(direction, currentFocusedElement, currentContainerIds) {
    var next = (0, _target.getTargetByDirectionFromElement)(direction, currentFocusedElement);

    if (next) {
      var currentContainerId = (0, _last["default"])(currentContainerIds);
      var nextContainerIds = (0, _container.getContainersForNode)(next); // prevent focus if 5-way is being held and the next element isn't wrapped by
      // the current element's immediate container

      if (_5WayKeyHold && nextContainerIds.indexOf(currentContainerId) < 0 && !(0, _container.isContainer5WayHoldable)(currentContainerId)) {
        return false;
      }

      (0, _container.notifyLeaveContainer)(direction, currentFocusedElement, currentContainerIds, next, nextContainerIds);
      (0, _container.setContainerPreviousTarget)(currentContainerId, direction, next, currentFocusedElement);
      var focused = focusElement(next, nextContainerIds);
      (0, _container.notifyEnterContainer)(direction, currentFocusedElement, currentContainerIds, next, nextContainerIds);
      return focused;
    }

    (0, _container.notifyLeaveContainerFail)(direction, currentFocusedElement, currentContainerIds);
    return false;
  }

  function onAcceleratedKeyDown(evt) {
    var direction = getDirection(evt.keyCode);
    if (!direction) return;

    var currentFocusedElement = _getCurrent();

    var currentContainerIds = (0, _container.getContainersForNode)(currentFocusedElement);
    spotNext(direction, currentFocusedElement, currentContainerIds);
  }

  function onBlur() {
    var current = _getCurrent();

    if (current) {
      current.blur();
    }

    Spotlight.setPointerMode(false);
    _spotOnWindowFocus = true;
    _pointerMoveDuringKeyPress = false;
  }

  function handleWebOSMouseEvent(ev) {
    if (!(0, _Pause.isPaused)() && ev && ev.detail && ev.detail.type === 'Leave') {
      onBlur();
    }
  }

  function handleKeyboardStateChangeEvent(_ref) {
    var visibility = _ref.visibility;

    if (!visibility) {
      setPlatformPointerMode();
    }
  }

  function onFocus() {
    // Normally, there isn't focus here unless the window has been blurred above. On webOS, the
    // platform may focus the window after the app has already focused a component so we prevent
    // trying to focus something else (potentially) unless the window was previously blurred
    if (_spotOnWindowFocus) {
      setPlatformPointerMode(); // If the window was previously blurred while in pointer mode, the last active containerId may
      // not have yet set focus to its spottable elements. For this reason we can't rely on setting focus
      // to the last focused element of the last active containerId, so we use rootContainerId instead

      var lastFocusedElement = (0, _container.getContainerLastFocusedElement)(_container.rootContainerId);

      while ((0, _container.isContainer)(lastFocusedElement)) {
        var _getContainerConfig2 = (0, _container.getContainerConfig)(lastFocusedElement);

        lastFocusedElement = _getContainerConfig2.lastFocusedElement;
      }

      if (!Spotlight.focus(lastFocusedElement)) {
        // If the last focused element was previously also disabled (or no longer exists), we
        // need to set focus somewhere
        Spotlight.focus();
      }

      _spotOnWindowFocus = false;
    }
  }

  function onKeyUp(evt) {
    _pointerMoveDuringKeyPress = false;
    var keyCode = evt.keyCode;

    if (getDirection(keyCode) || isEnter(keyCode)) {
      SpotlightAccelerator.reset();
      _5WayKeyHold = false;
    }
  }

  function handlePointerHide() {
    if (!_getCurrent()) {
      restoreFocus();
    }
  }

  function onKeyDown(evt) {
    if (shouldPreventNavigation()) {
      (0, _pointer.notifyKeyDown)(evt.keyCode);
      return;
    }

    var keyCode = evt.keyCode;
    var direction = getDirection(keyCode);
    var pointerHandled = (0, _pointer.notifyKeyDown)(keyCode, handlePointerHide);

    if (pointerHandled || !(direction || isEnter(keyCode))) {
      return;
    }

    if (!(0, _Pause.isPaused)() && !_pointerMoveDuringKeyPress) {
      if (_getCurrent()) {
        SpotlightAccelerator.processKey(evt, onAcceleratedKeyDown);
      } else if (!spotNextFromPoint(direction, (0, _pointer.getLastPointerPosition)())) {
        restoreFocus();
      }

      _5WayKeyHold = true;
    }

    if (direction) {
      preventDefault(evt);
    }
  }

  function onMouseMove(_ref2) {
    var target = _ref2.target,
        clientX = _ref2.clientX,
        clientY = _ref2.clientY;

    if (shouldPreventNavigation()) {
      (0, _pointer.notifyPointerMove)(null, target, clientX, clientY);
      return;
    }

    var current = _getCurrent();

    var update = (0, _pointer.notifyPointerMove)(current, target, clientX, clientY);

    if (update) {
      if (_5WayKeyHold) {
        _pointerMoveDuringKeyPress = true;
      }

      var next = (0, _target.getNavigableTarget)(target); // TODO: Consider encapsulating this work within focusElement

      if (next !== current) {
        if (next) {
          focusElement(next, (0, _container.getContainersForNode)(next), true);
          return true;
        } else if (current) {
          current.blur();
          (0, _container.setLastContainerFromTarget)(current, target);
        }
      }
    }
  }

  function onMouseOver(evt) {
    if (shouldPreventNavigation()) return;
    var target = evt.target;

    if ((0, _pointer.getPointerMode)() && (0, _pointer.hasPointerMoved)(evt.clientX, evt.clientY)) {
      var next = (0, _target.getNavigableTarget)(target); // account for child controls

      if (next && next !== _getCurrent()) {
        focusElement(next, (0, _container.getContainersForNode)(next), true);
        return true;
      }

      preventDefault(evt);
    }
  }

  function onTouchEnd(evt) {
    var current = _getCurrent();

    if (current && !current.contains(evt.target)) {
      current.blur();
    }
  }
  /*
   * public methods
   */


  var exports =
  /** @lends spotlight.Spotlight */
  {
    // eslint-disable-line no-shadow

    /**
     * Initializes Spotlight. This is generally handled by
     * {@link spotlight/SpotlightRootDecorator.SpotlightRootDecorator}.
     *
     * @param {Object} containerDefaults Default configuration for new spotlight containers
     * @returns {undefined}
     * @public
     */
    initialize: function initialize(containerDefaults) {
      if (!_initialized) {
        window.addEventListener('blur', onBlur);
        window.addEventListener('focus', onFocus);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        window.addEventListener('mouseover', onMouseOver);
        window.addEventListener('mousemove', onMouseMove);

        if (_platform["default"].touch) {
          window.addEventListener('touchend', onTouchEnd);
        }

        if (_platform["default"].webos) {
          window.top.document.addEventListener('webOSMouse', handleWebOSMouseEvent);
          window.top.document.addEventListener('keyboardStateChange', handleKeyboardStateChangeEvent);
        }

        (0, _container.setLastContainer)(_container.rootContainerId);
        (0, _container.configureDefaults)(containerDefaults);
        (0, _container.configureContainer)(_container.rootContainerId); // by default, pointer mode is off but the platform's current state will override that

        (0, _pointer.setPointerMode)(false);
        setPlatformPointerMode();
        _initialized = true;
      }
    },

    /**
     * Terminates Spotlight. This is generally handled by {@link spotlight.SpotlightRootDecorator}.
     *
     * @public
     */
    terminate: function terminate() {
      window.removeEventListener('blur', onBlur);
      window.removeEventListener('focus', onFocus);
      window.removeEventListener('keydown', onKeyDown);
      window.removeEventListener('keyup', onKeyUp);
      window.removeEventListener('mouseover', onMouseOver);
      window.removeEventListener('mousemove', onMouseMove);

      if (_platform["default"].touch) {
        window.removeEventListener('touchend', onTouchEnd);
      }

      if (_platform["default"].webos) {
        window.top.document.removeEventListener('webOSMouse', handleWebOSMouseEvent);
        window.top.document.removeEventListener('keyboardStateChange', handleKeyboardStateChangeEvent);
      }

      Spotlight.clear();
      _initialized = false;
    },

    /**
     * Resets spotlight container information
     *
     * @private
     */
    clear: function clear() {
      (0, _container.removeAllContainers)();
      (0, _container.setDefaultContainer)();
      (0, _container.setLastContainer)();
      _duringFocusChange = false;
    },
    // set(<config>);
    // set(<containerId>, <config>);

    /**
     * Sets the config for spotlight or the specified containerID
     *
     * @function
     * @param {String|Object} containerIdOrConfig  Configuration object or container ID
     * @param {Object}        [config]             Configuration object if container ID supplied
     *                                             in `containerIdOrConfig`
     * @returns {undefined}
     * @public
     */
    set: _container.configureContainer,
    // add(<config>);
    // add(<containerId>, <config>);

    /**
     * Adds the config for a new container. The container ID may be passed in the configuration
     * object. If no container ID is supplied, a new container ID will be generated.
     *
     * @function
     * @param {String|Object} containerIdOrConfig  Configuration object or container ID
     * @param {Object}        [config]             Configuration object if container ID supplied
     *                                             in `containerIdOrConfig`
     * @returns {String} The container ID of the container
     * @public
     */
    add: _container.addContainer,
    unmount: function unmount(containerId) {
      if (!containerId || typeof containerId !== 'string') {
        throw new Error('Please assign the "containerId"!');
      }

      (0, _container.unmountContainer)(containerId);
    },

    /**
     * Removes a container from Spotlight
     *
     * @param {String} containerId Container ID to remove
     * @returns {Boolean} `true` if container removed, `false` if container does not exist
     * @public
     */
    remove: function remove(containerId) {
      if (!containerId || typeof containerId !== 'string') {
        throw new Error('Please assign the "containerId"!');
      }

      if ((0, _container.getContainerConfig)(containerId)) {
        (0, _container.removeContainer)(containerId);

        if ((0, _container.getLastContainer)() === containerId) {
          Spotlight.setActiveContainer(null);
        }

        return true;
      }

      return false;
    },

    /**
     * Disables the selector rules of the specified container
     *
     * @param {String} containerId Container ID selector rules to disable
     * @returns {Boolean} `true` if container's selector rules are disabled, `false` if container does not exist
     * @public
     */
    disableSelector: function disableSelector(containerId) {
      if ((0, _container.isContainer)(containerId)) {
        (0, _container.configureContainer)(containerId, {
          selectorDisabled: false
        });
        return true;
      }

      return false;
    },

    /**
     * Enables the selector rules of the specified container
     *
     * @param {String} containerId Container ID selector rules to enable
     * @returns {Boolean} `true` if container's selector rules are enabled, `false` if container does not exist
     * @public
     */
    enableSelector: function enableSelector(containerId) {
      if ((0, _container.isContainer)(containerId)) {
        (0, _container.configureContainer)(containerId, {
          selectorDisabled: false
        });
        return true;
      }

      return false;
    },

    /**
     * Pauses Spotlight
     *
     * @function
     * @returns {undefined}
     * @public
     */
    pause: _Pause.pause,

    /**
     * Resumes Spotlight
     *
     * @function
     * @returns {undefined}
     * @public
     */
    resume: _Pause.resume,
    // focus()
    // focus(<containerId>)
    // focus(<extSelector>)

    /**
     * Focuses the specified component ID, container ID, element selector, or the default
     * container.
     *
     * If Spotlight is in pointer mode, focus is not changed but `elem` will be set as the last
     * focused element of its spotlight containers.
     *
     * @param {String|Node} [elem] The spotlight ID or selector for either a spottable
     *  component or a spotlight container, or spottable node. If not supplied, the default
     *  container will be focused.
     * @param {Object} [containerOption] The object including `enterTo` and `toOuterContainer`.
     *  It works when the first parameter `elem` is either a spotlight container ID or a spotlight container node.
     * @param {('last-focused'|'default-element'|'topmost')} [containerOption.enterTo] Specifies preferred
     *  `enterTo` configuration.
     * @param {Boolean} [containerOption.toOuterContainer] If the proper target is not found, search one
     *  recursively to outer container.
     * @returns {Boolean} `true` if focus successful, `false` if not.
     * @public
     */
    focus: function focus(elem) {
      var containerOption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var target = elem;
      var wasContainerId = false;
      var currentContainerNode = null;

      if (!elem) {
        target = (0, _target.getTargetByContainer)();
      } else if (typeof elem === 'string') {
        if ((0, _container.getContainerConfig)(elem)) {
          target = (0, _target.getTargetByContainer)(elem, containerOption.enterTo);
          wasContainerId = true;
          currentContainerNode = (0, _container.getContainerNode)(elem);
        } else if (/^[\w\d-]+$/.test(elem)) {
          // support component IDs consisting of alphanumeric, dash, or underscore
          target = (0, _target.getTargetBySelector)("[data-spotlight-id=".concat(elem, "]"));
        } else {
          target = (0, _target.getTargetBySelector)(elem);
        }
      } else if ((0, _container.isContainer)(elem)) {
        target = (0, _target.getTargetByContainer)((0, _container.getContainerId)(elem), containerOption.enterTo);
        currentContainerNode = elem;
      }

      var nextContainerIds = (0, _container.getContainersForNode)(target);
      var nextContainerId = (0, _last["default"])(nextContainerIds);

      if ((0, _container.isNavigable)(target, nextContainerId, true)) {
        var focused = focusElement(target, nextContainerIds);

        if (!focused && wasContainerId) {
          (0, _container.setLastContainer)(elem);
        }

        return focused;
      } else if (wasContainerId) {
        // if we failed to find a spottable target within the provided container, we'll set
        // it as the active container to allow it to focus itself if its contents change
        (0, _container.setLastContainer)(elem);
      }

      if (containerOption.toOuterContainer && currentContainerNode) {
        var outerContainer = (0, _container.getContainersForNode)(currentContainerNode.parentElement).pop();

        if (outerContainer) {
          return this.focus(outerContainer, containerOption);
        }
      }

      return false;
    },
    // move(<direction>)
    // move(<direction>, <selector>)

    /**
     * Moves focus to the next spottable control in the direction specified. Optionally, a source
     * element selector may be supplied as the starting point.
     *
     * @param {String} direction Direction to move, one of `'left'`, `'right'`, `'up'` or `'down'`
     * @param {String|undefined} selector If supplied, the element to move from. If not supplied,
     *	the currently focused item will be used.
     * @returns {Boolean} `true` if focus successful, `false` if not.
     * @public
     */
    move: function move(direction, selector) {
      direction = direction.toLowerCase();

      if (direction !== 'up' && direction !== 'down' && direction !== 'left' && direction !== 'right') {
        return false;
      }

      var elem = selector ? (0, _utils.parseSelector)(selector)[0] : _getCurrent();

      if (!elem) {
        return false;
      }

      var containerIds = (0, _container.getContainersForNode)(elem);

      if (!containerIds.length) {
        return false;
      }

      return spotNext(direction, elem, containerIds);
    },

    /**
     * Sets or clears the default container that will receive focus.
     *
     * @function
     * @param {String} [containerId] The container ID or a falsy value to clear default
     *                               container
     * @returns {undefined}
     * @public
     */
    setDefaultContainer: _container.setDefaultContainer,

    /**
     * Gets the currently active container.
     *
     * @returns {String} The id of the currently active container
     * @public
     */
    getActiveContainer: function getActiveContainer() {
      return (0, _container.getLastContainer)() || _container.rootContainerId;
    },

    /**
     * Sets the currently active container.
     *
     * Note: If the current container is restricted to 'self-only' and `containerId` is not
     * contained within the current container then the active container will not be updated.
     *
     * @param {String} [containerId] The id of the currently active container. If this is not
     *	provided, the root container is set as the currently active container.
     * @public
     */
    setActiveContainer: function setActiveContainer(containerId) {
      if ((0, _container.mayActivateContainer)(containerId)) {
        (0, _container.setLastContainer)(containerId || _container.rootContainerId);
      }
    },

    /**
     * Gets the current pointer mode
     *
     * @function
     * @returns {Boolean} `true` if spotlight is in pointer mode
     * @public
     */
    getPointerMode: _pointer.getPointerMode,

    /**
     * Sets the current pointer mode
     *
     * @function
     * @param {Boolean} pointerMode The value of the pointer mode. This determines how
     *	spotlight manages focus change behaviors.
     * @public
     */
    setPointerMode: _pointer.setPointerMode,

    /**
     * Gets the muted mode value of a spottable element.
     *
     * @param {Object} elem The dom element used to determine the muted status.
     * @returns {Boolean} `true` if the passed-in control is in muted mode.
     * @public
     */
    isMuted: function isMuted(elem) {
      if (!elem) {
        return false;
      }

      return (0, _utils.matchSelector)('[data-spotlight-container-muted="true"] .' + _Spottable.spottableClass, elem);
    },

    /**
     * Determines whether Spotlight is currently paused.
     *
     * @function
     * @returns {Boolean} `true` if Spotlight is currently paused.
     * @public
     */
    isPaused: _Pause.isPaused,

    /**
     * Determines whether an element is spottable.
     *
     * @param {Object} elem The dom element used to determine the spottable status.
     * @returns {Boolean} `true` if the element being evaluated is currently spottable.
     * @public
     */
    isSpottable: function isSpottable(elem) {
      if (!elem) {
        return false;
      }

      return (0, _target.isFocusable)(elem);
    },

    /**
     * Returns the currently spotted control.
     *
     * @returns {Node} The control that currently has focus, if available
     * @public
     */
    getCurrent: function getCurrent() {
      return _getCurrent();
    },

    /**
     * Returns a list of spottable elements wrapped by the supplied container.
     *
     * @param {String} containerId The id of the container used to determine the list of spottable elements
     * @returns {Node[]} The spottable elements that are wrapped by the supplied container
     * @public
     */
    getSpottableDescendants: function getSpottableDescendants(containerId) {
      if (!containerId || typeof containerId !== 'string') {
        throw new Error('Please assign the "containerId"!');
      }

      return (0, _container.getSpottableDescendants)(containerId);
    },

    /**
     * Focuses the next spottable control from the position specified in the direction specified.
     *
     * @param {String} direction Direction to move, one of `'left'`, `'right'`, `'up'`, or `'down'`
     * @param {Object} position `x` and `y` coordinates for the pointer
     * @private
     */
    focusNextFromPoint: spotNextFromPoint
  };
  return exports;
}();

exports.Spotlight = Spotlight;
var _default = Spotlight;
exports["default"] = _default;