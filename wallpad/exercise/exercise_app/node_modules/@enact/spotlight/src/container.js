"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContainerConfig = exports.getAllContainerIds = exports.containerAttribute = exports.configureDefaults = exports.configureContainer = exports.addContainer = void 0;
exports.getContainerDefaultElement = getContainerDefaultElement;
exports.getContainerFocusTarget = getContainerFocusTarget;
exports.getContainerId = void 0;
exports.getContainerLastFocusedElement = getContainerLastFocusedElement;
exports.getContainerNavigableElements = getContainerNavigableElements;
exports.getContainerNode = void 0;
exports.getContainerPreviousTarget = getContainerPreviousTarget;
exports.getContainersForNode = getContainersForNode;
exports.getDeepSpottableDescendants = void 0;
exports.getDefaultContainer = getDefaultContainer;
exports.getLastContainer = getLastContainer;
exports.getNavigableContainersForNode = getNavigableContainersForNode;
exports.isNavigable = exports.isContainer5WayHoldable = exports.isContainer = exports.getSpottableDescendants = void 0;
exports.isWithinOverflowContainer = isWithinOverflowContainer;
exports.mayActivateContainer = mayActivateContainer;
exports.notifyEnterContainer = notifyEnterContainer;
exports.notifyLeaveContainer = notifyLeaveContainer;
exports.notifyLeaveContainerFail = notifyLeaveContainerFail;
exports.rootContainerId = exports.removeContainer = exports.removeAllContainers = void 0;
exports.setContainerLastFocusedElement = setContainerLastFocusedElement;
exports.setContainerPreviousTarget = setContainerPreviousTarget;
exports.setDefaultContainer = setDefaultContainer;
exports.setLastContainer = setLastContainer;
exports.setLastContainerFromTarget = setLastContainerFromTarget;
exports.unmountContainer = unmountContainer;

var _and = _interopRequireDefault(require("ramda/src/and"));

var _concat = _interopRequireDefault(require("ramda/src/concat"));

var _snapshot = require("@enact/core/snapshot");

var _util = require("@enact/core/util");

var _intersection = _interopRequireDefault(require("ramda/src/intersection"));

var _last = _interopRequireDefault(require("ramda/src/last"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var containerAttribute = 'data-spotlight-id';
exports.containerAttribute = containerAttribute;
var containerConfigs = new Map();
var containerKey = 'spotlightId';
var disabledKey = 'spotlightContainerDisabled';
var containerPrefix = 'container-';
var containerSelector = '[data-spotlight-container]';
var rootContainerId = 'spotlightRootDecorator';
exports.rootContainerId = rootContainerId;
var reverseDirections = {
  'left': 'right',
  'up': 'down',
  'right': 'left',
  'down': 'up'
}; // Incrementer for container IDs

var _ids = 0;
var _defaultContainerId = '';
var _lastContainerId = ''; // Note: an <extSelector> can be one of following types:
// - a valid selector string for "querySelectorAll"
// - a NodeList or an array containing DOM elements
// - a single DOM element
// - a string "@<containerId>" to indicate the specified container
// - a string "@" to indicate the default container

var GlobalConfig = {
  // set to false for unmounted containers to omit them from searches
  active: true,
  continue5WayHold: false,
  defaultElement: '',
  // <extSelector> except "@" syntax.
  enterTo: '',
  // '', 'last-focused', 'default-element'
  lastFocusedElement: null,
  lastFocusedKey: null,
  lastFocusedPersist: function lastFocusedPersist(node, all) {
    var container = typeof node === 'string';
    return {
      container: container,
      element: !container,
      key: container ? node : all.indexOf(node)
    };
  },
  lastFocusedRestore: function lastFocusedRestore(_ref, all) {
    var container = _ref.container,
        key = _ref.key;
    return container ? key : all[key];
  },
  leaveFor: null,
  // {left: <extSelector>, right: <extSelector>, up: <extSelector>, down: <extSelector>}
  navigableFilter: null,
  obliqueMultiplier: 5,
  onEnterContainer: null,
  // @private - notify the container when entering via 5-way
  onLeaveContainer: null,
  // @private - notify the container when leaving via 5-way
  onLeaveContainerFail: null,
  // @private - notify the container when failing to leave via 5-way
  overflow: false,
  partition: false,
  // use the container bounds for partitioning when leaving
  rememberSource: false,
  restrict: 'self-first',
  // 'self-first', 'self-only', 'none'
  selector: '',
  // can be a valid <extSelector> except "@" syntax.
  selectorDisabled: false,
  straightMultiplier: 1,
  straightOnly: false,
  straightOverlapThreshold: 0.5,
  tabIndexIgnoreList: 'a, input, select, textarea, button, iframe, [contentEditable=true]'
};
/**
 * Calculates nodes within `node` that match `includeSelector` and do not match `excludeSelector`
 *
 * @param   {Node}    node             DOM Node to query
 * @param   {String}  includeSelector  CSS selector of nodes to include
 * @param   {String}  excludeSelector  CSS selector for nodes to exclude
 *
 * @returns {Node[]}                   Array of nodes
 * @memberof spotlight/container
 * @private
 */

var querySelector = function querySelector(node, includeSelector, excludeSelector) {
  var include = new Set(node.querySelectorAll(includeSelector));
  var exclude = node.querySelectorAll(excludeSelector);

  for (var i = 0; i < exclude.length; i++) {
    include["delete"](exclude[i]);
  }

  return Array.from(include);
};
/**
 * Determines if `node` is a spotlight container
 *
 * @param   {Node}     node   Node to check
 *
 * @returns {Boolean}        `true` if `node` is a spotlight container
 * @memberof spotlight/container
 * @private
 */


var isContainerNode = function isContainerNode(node) {
  return node && node.dataset && 'spotlightContainer' in node.dataset;
};
/**
 * Walks up the node hierarchy calling `fn` on each node that is a container
 *
 * @param   {Node}     node  Node from which to start the search
 * @param   {Function} fn    Called once for each container with the container node as the first
 *                           argument. The return value is accumulated in the array returned by
 *                           `mapContainers`
 *
 * @returns {Array}          Array of values returned by `fn` in order of outermost container to
 *                           innermost container
 * @memberof spotlight/container
 * @private
 */


var mapContainers = function mapContainers(node, fn) {
  var result = [];

  while (node && node !== document) {
    if (isContainerNode(node)) {
      result.unshift(fn(node));
    }

    node = node.parentNode;
  }

  return result;
};
/**
 * Returns the container config for `containerId`
 *
 * @param   {String}  id  Container ID
 *
 * @returns {Object}      Container config
 * @memberof spotlight/container
 * @private
 */


var getContainerConfig = function getContainerConfig(id) {
  return containerConfigs.get(id);
};
/**
 * Determines if node or a container id represents a spotlight container
 *
 * @param   {Node|String}  nodeOrId  Node or container ID
 *
 * @returns {Boolean}                `true` if `nodeOrId` represents a spotlight container
 * @memberof spotlight/container
 * @private
 */


exports.getContainerConfig = getContainerConfig;

var isContainer = function isContainer(nodeOrId) {
  if (typeof nodeOrId === 'string') {
    return containerConfigs.has(nodeOrId);
  }

  return isContainerNode(nodeOrId);
};
/**
 * Determines if any of the containers at or above `node` are disabled and, if so, returns `false`.
 *
 * @param   {Node}     node  Spottable node or spotlight container
 *
 * @returns {Boolean}        `true` if all container ancestors are enabled
 * @memberof spotlight/container
 * @private
 */


exports.isContainer = isContainer;

var isContainerEnabled = function isContainerEnabled(node) {
  return mapContainers(node, function (container) {
    return container.dataset[disabledKey] !== 'true';
  }).reduce(_and["default"], true);
};
/**
 * Returns the container ID for `node`
 *
 * @param   {Node}    node  Container Node
 *
 * @returns {String}        Container ID
 * @memberof spotlight/container
 * @private
 */


var getContainerId = function getContainerId(node) {
  return node.dataset[containerKey];
};
/**
 * Generates a CSS selector string for a current container if `node` is a container
 *
 * @param   {Node}    node  Container Node
 *
 * @returns {String}        CSS selector
 * @memberof spotlight/container
 * @private
 */


exports.getContainerId = getContainerId;

var getContainerSelector = function getContainerSelector(node) {
  if (isContainerNode(node)) {
    return "[".concat(containerAttribute, "=\"").concat(getContainerId(node), "\"]");
  }

  return '';
};
/**
 * Generates a CSS selector string for containers within `node` if it is a container
 *
 * @param   {Node}    node  Container Node
 *
 * @returns {String}        CSS selector
 * @memberof spotlight/container
 * @private
 */


var getSubContainerSelector = function getSubContainerSelector(node) {
  if (isContainerNode(node)) {
    return "".concat(getContainerSelector(node), " ").concat(containerSelector);
  }

  return containerSelector;
};
/**
 * Returns the node for a container
 *
 * @param   {String}  containerId  ID of container
 *
 * @returns {Node}                 DOM node of the container
 * @memberof spotlight/container
 * @private
 */


var getContainerNode = function getContainerNode(containerId) {
  if (!containerId) {
    return null;
  } else if (containerId === rootContainerId) {
    return document;
  }

  return document.querySelector("[".concat(containerAttribute, "=\"").concat(containerId, "\"]"));
};
/**
 * Calls the `navigableFilter` function for the container if defined.
 *
 * @param   {Node}    node         DOM node to check if it is navigable
 * @param   {String}  containerId  ID of container
 *
 * @returns {Boolean}              `true` if it passes the `navigableFilter` method or if that
 *                                  method is not defined for the container
 * @memberof spotlight/container
 * @private
 */


exports.getContainerNode = getContainerNode;

var navigableFilter = function navigableFilter(node, containerId) {
  var nodeStyle = node && (0, _snapshot.isWindowReady)() && window.getComputedStyle(node);
  var config = getContainerConfig(containerId);

  if (!nodeStyle || nodeStyle.display === 'none' || nodeStyle.visibility === 'hidden') {
    return false;
  }

  if (config && typeof config.navigableFilter === 'function') {
    if (config.navigableFilter(node, containerId) === false) {
      return false;
    }
  }

  return true;
};
/**
 * Determines nodes that are owned by `node` based on `aria-owns`.
 *
 * @param   {Node}   node          Owner
 *
 * @returns {Node[]}               Array of owned nodes
 * @memberof spotlight/container
 * @private
 */


var getOwnedNodes = function getOwnedNodes(node, selector) {
  // if node is document, it will not have getAttribute and therefore can't have aria-owns
  var owns = node && node.getAttribute && node.getAttribute('aria-owns');

  if (owns) {
    var ids = owns.split(' ');
    return ids.map(function (id) {
      return id && document.getElementById(id);
    }).filter(Boolean).filter(function (n) {
      return isContainerNode(n) || (0, _utils.matchSelector)(selector, n);
    });
  }

  return [];
};
/**
 * Determines all spottable elements and containers that are directly contained by the container
 * identified by `containerId` and no other subcontainers.
 *
 * @param   {String}  containerId  ID of container
 *
 * @returns {Node[]}               Array of spottable elements and containers.
 * @memberof spotlight/container
 * @public
 */


var getSpottableDescendants = function getSpottableDescendants(containerId) {
  var node = getContainerNode(containerId); // if it's falsy or is a disabled container, return an empty set

  if (!node || isContainerNode(node) && !isContainerEnabled(node)) {
    return [];
  }

  var _ref2 = getContainerConfig(containerId) || {},
      selector = _ref2.selector,
      selectorDisabled = _ref2.selectorDisabled;

  if (!selector || selectorDisabled) {
    return [];
  }

  var spottableSelector = selector;
  var subContainerSelector = getSubContainerSelector(node);
  var candidates = querySelector(node, "".concat(spottableSelector, ", ").concat(getContainerSelector(node), " ").concat(containerSelector, ":not([data-spotlight-container-disabled=\"true\"])"), "".concat(subContainerSelector, " ").concat(spottableSelector, ", ").concat(subContainerSelector, " ").concat(containerSelector));
  candidates.push.apply(candidates, _toConsumableArray(getOwnedNodes(node, selector)));
  return candidates.filter(function (n) {
    return navigableFilter(n, containerId);
  });
};
/**
 * Recursively get spottable descendants by including elements within sub-containers that do not
 * have `enterTo` configured
 *
 * @param   {String}    containerId          ID of container
 * @param   {String[]}  [excludedContainers] IDs of containers to exclude from result set
 *
 * @returns {Node[]}                         Array of spottable elements and containers
 * @memberof spotlight/container
 * @private
 */


exports.getSpottableDescendants = getSpottableDescendants;

var getDeepSpottableDescendants = function getDeepSpottableDescendants(containerId, excludedContainers) {
  return getSpottableDescendants(containerId).map(function (n) {
    if (isContainer(n)) {
      var id = getContainerId(n);
      var config = getContainerConfig(id);

      if (excludedContainers && excludedContainers.indexOf(id) >= 0) {
        return [];
      } else if (config && !config.enterTo) {
        return getDeepSpottableDescendants(id, excludedContainers);
      }
    }

    return [n];
  }).reduce(_concat["default"], []);
};
/**
 * Determines if a container allows 5-way key hold to be preserved or not.
 *
 * @param {String} containerId Container Id
 * @returns {Boolean} `true` if a container is 5 way holdable
 * @memberof spotlight/container
 * @private
 */


exports.getDeepSpottableDescendants = getDeepSpottableDescendants;

var isContainer5WayHoldable = function isContainer5WayHoldable(containerId) {
  var config = getContainerConfig(containerId);
  return config && config.continue5WayHold || false;
};
/**
 * Returns an array of ids for containers that wrap the element, in order of outer-to-inner, with
 * the last array item being the immediate container id of the element.
 *
 * @param   {Node}      node  Node from which to start the search
 *
 * @returns {String[]}        Array on container IDs
 * @memberof spotlight/container
 * @private
 */


exports.isContainer5WayHoldable = isContainer5WayHoldable;

function getContainersForNode(node) {
  var containers = mapContainers(node, getContainerId);
  containers.unshift(rootContainerId);
  return containers;
}
/**
 * Returns an array of ids for containers that wrap the element, in order of outer-to-inner, with
 * the last array item being the immediate container id of the element. The container ids are
 * limited to only those between `node` and the first restrict="self-only" container.
 *
 * @param   {Node}      node  Node from which to start the search
 *
 * @returns {String[]}        Array on container IDs
 * @memberof spotlight/container
 * @private
 */


function getNavigableContainersForNode(node) {
  var containerIds = getContainersForNode(node); // find first self-only container id

  var selfOnlyIndex = containerIds.map(getContainerConfig).filter(function (config) {
    return config != null;
  }).reduceRight(function (index, config, i) {
    if (index === -1 && config.restrict === 'self-only') {
      return i;
    }

    return index;
  }, -1); // if we found one (and it's not the root), slice those off and return

  if (selfOnlyIndex > 0) {
    return containerIds.slice(selfOnlyIndex);
  }

  return containerIds;
}
/**
 * Generates a new unique identifier for a container
 *
 * @returns {String} Container ID
 * @memberof spotlight/container
 * @private
 */


function generateId() {
  var id;
  /* eslint no-constant-condition: ["error", { "checkLoops": false }] */

  while (true) {
    id = containerPrefix + String(++_ids);

    if (!isContainer(id)) {
      break;
    }
  }

  return id;
}
/**
 * Merges two container configurations while only allowing keys from `updated` which are defined in
 * `GlobalConfig`
 *
 * @param   {Object}  current  Current container configuration
 * @param   {Object}  updated  Updated configuration which may only be a partial configuration
 *
 * @returns {Object}           Merged configuration
 * @memberof spotlight/container
 * @private
 */


var mergeConfig = function mergeConfig(current, updated) {
  if (!updated) return current;
  var cfg = null;
  Object.keys(updated).forEach(function (key) {
    if (key in GlobalConfig && current[key] !== updated[key]) {
      if (cfg == null) {
        cfg = Object.assign({}, current);
      }

      cfg[key] = updated[key];
    }
  });
  return cfg || current;
};
/**
 * Adds or updates a container. When a container id is not specified, it will be generated.
 *
 * @param   {String|Object}  containerIdOrConfig  Either a string container id or a configuration
 *                                                object.
 * @param   {Object}         [config]             Container configuration when `containerIdOrConfig`
 *                                                is a string. When omitted, the container will have
 *                                                the default `GlobalConfig`.
 *
 * @returns {String}                              The container id
 * @memberof spotlight/container
 * @public
 */


var configureContainer = function configureContainer() {
  var containerId, config;

  if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'object') {
    config = arguments.length <= 0 ? undefined : arguments[0];
    containerId = config.id;
  } else if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
    containerId = arguments.length <= 0 ? undefined : arguments[0];

    if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'object') {
      config = arguments.length <= 1 ? undefined : arguments[1];
    }
  }

  if (!containerId) {
    containerId = generateId();
  }

  config = mergeConfig(containerConfigs.get(containerId) || _objectSpread({}, GlobalConfig), config);
  containerConfigs.set(containerId, config);
  return containerId;
};
/**
 * Adds a container and marks it active. When a container id is not specified, it will be generated.
 *
 * @param   {String|Object}  containerIdOrConfig  Either a string container id or a configuration
 *                                                object.
 * @param   {Object}         [config]             Container configuration when `containerIdOrConfig`
 *                                                is a string. When omitted, the container will have
 *                                                the default `GlobalConfig`.
 *
 * @returns {String}                              The container id
 * @memberof spotlight/container
 * @public
 */


exports.configureContainer = configureContainer;

var addContainer = function addContainer() {
  var containerId = configureContainer.apply(void 0, arguments);
  var config = getContainerConfig(containerId);
  config.active = true;
  return containerId;
};
/**
 * Removes a container
 *
 * @param   {String}     containerId  ID of the container to remove
 *
 * @returns {undefined}
 * @memberof spotlight/container
 * @public
 */


exports.addContainer = addContainer;

var removeContainer = function removeContainer(containerId) {
  containerConfigs["delete"](containerId);
};
/**
 * Removes all containers
 *
 * @returns {undefined}
 * @memberof spotlight/container
 * @public
 */


exports.removeContainer = removeContainer;

var removeAllContainers = function removeAllContainers() {
  containerConfigs.clear();
};
/**
 * Configures the `GlobalConfig` for containers
 *
 * @param   {Object}  config  New global configuration. Cannot introduce new keys
 *
 * @returns {undefined}
 * @memberof spotlight/container
 * @public
 */


exports.removeAllContainers = removeAllContainers;

var configureDefaults = function configureDefaults(config) {
  GlobalConfig = mergeConfig(GlobalConfig, config);
};
/**
 * Determines if `node` is a navigable element within the container identified by `containerId`.
 *
 * @param   {Node}     node         DOM node to check if it is navigable
 * @param   {String}   containerId  ID of the container containing `node`
 * @param   {Boolean}  verify       `true` to verify the node matches the container's `selector`
 *
 * @returns {Boolean}               `true` if `node` is navigable
 * @memberof spotlight/container
 * @public
 */


exports.configureDefaults = configureDefaults;

var isNavigable = function isNavigable(node, containerId, verify) {
  if (!node || // jsdom reports all nodes as having no size so we must skip this condition in our tests
  process.env.NODE_ENV !== 'test' && node.offsetWidth <= 0 && node.offsetHeight <= 0) {
    return false;
  }

  var containerNode = getContainerNode(containerId);

  if (containerNode !== document && containerNode.dataset[disabledKey] === 'true') {
    return false;
  }

  var config = getContainerConfig(containerId);

  if (verify && config && config.selector && !isContainer(node) && !(0, _utils.matchSelector)(config.selector, node)) {
    return false;
  }

  return navigableFilter(node, containerId);
};
/**
 * Returns the IDs of all containers
 *
 * @returns {String[]}  Array of container IDs
 * @memberof spotlight/container
 * @private
 */


exports.isNavigable = isNavigable;

var getAllContainerIds = function getAllContainerIds() {
  var ids = [];
  var keys = containerConfigs.keys(); // PhantomJS-friendly iterator->array conversion

  var id;

  while ((id = keys.next()) && !id.done) {
    if (isActiveContainer(id.value)) {
      ids.push(id.value);
    }
  }

  return ids;
};
/**
 * Returns the default focus element for a container
 *
 * @param   {String}                                       containerId        Container ID
 * @param   {('last-focused'|'default-element'|'topmost')} [preferredEnterTo] Prefer the given enterTo configuration
 *
 * @returns {Node|null}                 Default focus element
 * @memberof spotlight/container
 * @public
 */


exports.getAllContainerIds = getAllContainerIds;

function getContainerDefaultElement(containerId, preferredEnterTo) {
  var config = getContainerConfig(containerId);
  var defaultElementSelector = config && config.defaultElement;

  if (!defaultElementSelector) {
    return null;
  }

  defaultElementSelector = (0, _util.coerceArray)(defaultElementSelector); // If a preferred enterTo has been provided, we will favor it by making it first in search array

  if (preferredEnterTo && typeof preferredEnterTo === 'string' && preferredEnterTo !== 'default-element') {
    defaultElementSelector.unshift(preferredEnterTo);
  }

  var spottables = getDeepSpottableDescendants(containerId);
  return defaultElementSelector.reduce(function (result, selector) {
    if (result) {
      return result;
    }

    if (typeof selector === 'string') {
      return spottables.filter(function (elem) {
        return (0, _utils.matchSelector)(selector, elem) && isNavigable(elem, containerId, true);
      })[0];
    } // FIXME: There is some prior implicit support for `defaultElement` to be an element rather
    // than a selector. This continues that support but should eventually be removed.


    return selector;
  }, null);
}
/**
 * Gets the element last focused within the container.
 *
 * @param   {String}       containerId  ID of container
 *
 * @returns {Node|String|null}               DOM Node last focused
 * @memberof spotlight/container
 * @public
 */


function getContainerLastFocusedElement(containerId) {
  var config = getContainerConfig(containerId);

  if (!config || !config.lastFocusedElement) {
    return null;
  } // lastFocusedElement may be a container ID so try to convert it to a node to test navigability


  var lastFocusedElement = config.lastFocusedElement;
  var node = lastFocusedElement;

  if (typeof node === 'string') {
    node = getContainerNode(lastFocusedElement);
  }

  return isNavigable(node, containerId, true) ? lastFocusedElement : null;
}
/**
 * Sets the element last focused within the container
 *
 * @param   {Node}      node         DOM node last focused
 * @param   {String[]}  containerId  ID of container
 *
 * @returns {undefined}
 * @memberof spotlight/container
 * @public
 */


function setContainerLastFocusedElement(node, containerIds) {
  var lastFocusedElement = node;

  for (var i = containerIds.length - 1; i > -1; i--) {
    var id = containerIds[i];
    configureContainer(id, {
      lastFocusedElement: lastFocusedElement
    }); // If any container in the stack is controlling entering focus, use its container id as the
    // lastFocusedElement instead of the node

    var config = getContainerConfig(id);

    if (config.enterTo) {
      lastFocusedElement = id;
    }
  }
}
/**
 * Returns all navigable nodes (spottable nodes or containers) visible from outside the container.
 * If the container is restricting navigation into itself via `enterTo`, this method will attempt to
 * return that element as the only element in an array. If that fails or if navigation is not
 * restricted, it will return an array of all possible navigable nodes.
 *
 * @param   {String}                                       containerId        Container ID
 * @param   {('last-focused'|'default-element'|'topmost')} [preferredEnterTo] Prefer the given enterTo configuration
 *
 * @returns {Node[]}             Navigable elements within container
 * @memberof spotlight/container
 * @public
 */


function getContainerNavigableElements(containerId, preferredEnterTo) {
  if (!isContainer(containerId)) {
    return [];
  }

  var config = getContainerConfig(containerId);
  var enterTo = config.enterTo,
      overflow = config.overflow;
  var enterLast = preferredEnterTo === 'last-focused' || enterTo === 'last-focused' && !preferredEnterTo;
  var next; // if the container has a preferred entry point, try to find it first

  if (enterLast) {
    next = getContainerLastFocusedElement(containerId);
  } // try default element if last focused can't be focused


  if (!next) {
    next = getContainerDefaultElement(containerId, preferredEnterTo);
  }

  if (!next) {
    var spottables = overflow ? // overflow requires deep recursion to handle selecting the children of unrestricted
    // containers or restricted containers larger than the container
    getDeepSpottableDescendants(containerId) : getSpottableDescendants(containerId); // if there isn't a preferred entry on an overflow container, filter the visible elements

    if (overflow) {
      var containerRect = (0, _utils.getContainerRect)(containerId);
      next = containerRect && spottables.filter(function (element) {
        var elementRect = (0, _utils.getRect)(element);

        if (isContainer(element)) {
          return (0, _utils.intersects)(containerRect, elementRect);
        }

        return (0, _utils.contains)(containerRect, (0, _utils.getRect)(element));
      });

      if (next && preferredEnterTo === 'topmost') {
        next.sort(function (a, b) {
          return (0, _utils.getRect)(a).top - (0, _utils.getRect)(b).top;
        });
      }
    } // otherwise, return all spottables within the container


    if (!next) {
      next = spottables;
    }
  }

  return next ? (0, _util.coerceArray)(next) : [];
}
/**
 * Determines the preferred focus target, traversing any sub-containers as necessary, for the given
 * container.
 *
 * @param   {String}                                       containerId        Container ID
 * @param   {('last-focused'|'default-element'|'topmost')} [preferredEnterTo] Prefer the given enterTo configuration
 *
 * @returns {Node}                 Preferred target as either a DOM node or container-id
 * @memberof spotlight/container
 * @public
 */


function getContainerFocusTarget(containerId, preferredEnterTo) {
  // deferring restoration until it's requested to allow containers to prepare first
  restoreLastFocusedElement(containerId);
  var next = getContainerNavigableElements(containerId, preferredEnterTo); // If multiple candidates returned, we need to find the first viable target since some may
  // be empty containers which should be skipped.

  return next.reduce(function (result, element) {
    if (result) {
      return result;
    } else if (isContainer(element)) {
      var nextId = isContainerNode(element) ? getContainerId(element) : element;
      return getContainerFocusTarget(nextId);
    }

    return element;
  }, null) || null;
}

function getContainerPreviousTarget(containerId, direction, destination) {
  var config = getContainerConfig(containerId);

  if (config && config.rememberSource && config.previous && config.previous.reverse === direction && config.previous.destination === destination) {
    return config.previous.target;
  }
}

function setContainerPreviousTarget(containerId, direction, destination, target) {
  var config = getContainerConfig(containerId);

  if (config && config.rememberSource) {
    configureContainer(containerId, {
      previous: {
        target: target,
        destination: destination,
        reverse: reverseDirections[direction]
      }
    });
  }
}
/**
 * Saves the last focused element into `lastFocusedKey` using a container-defined serialization
 * method configured in `lastFocusedPersist`.
 *
 * @param   {String}     containerId  ID of container
 *
 * @returns {undefined}
 * @memberof spotlight/container
 * @public
 */


function persistLastFocusedElement(containerId) {
  var cfg = getContainerConfig(containerId);

  if (cfg) {
    var lastFocusedElement = cfg.lastFocusedElement;

    if (lastFocusedElement) {
      var all = getDeepSpottableDescendants(containerId);
      var lastFocusedKey = cfg.lastFocusedPersist(lastFocusedElement, all); // store lastFocusedKey and release node reference to lastFocusedElement

      cfg.lastFocusedKey = lastFocusedKey;
      cfg.lastFocusedElement = null;
    }
  }
}
/**
 * Restores the last focused element from `lastFocusedKey` using a container-defined deserialization
 * method configured in `lastFocusedRestore`.
 *
 * @param   {String}     containerId  ID of container
 *
 * @returns {undefined}
 * @memberof spotlight/container
 * @public
 */


function restoreLastFocusedElement(containerId) {
  var cfg = getContainerConfig(containerId);

  if (cfg && cfg.lastFocusedKey) {
    var all = getDeepSpottableDescendants(containerId);
    var lastFocusedElement = cfg.lastFocusedRestore(cfg.lastFocusedKey, all); // restore lastFocusedElement and release lastFocusedKey

    cfg.lastFocusedKey = null;
    cfg.lastFocusedElement = lastFocusedElement;
  }
}

function unmountContainer(containerId) {
  var config = getContainerConfig(containerId);

  if (config) {
    config.active = false;
    persistLastFocusedElement(containerId);

    if (typeof config.defaultElement !== 'string') {
      config.defaultElement = null;
    }
  }
}

function isActiveContainer(containerId) {
  var config = getContainerConfig(containerId);
  return config && config.active;
}
/**
 * Determines if the provided container has a configured restriction.
 *
 * By default, returns `true` for `'self-only'` restrictions but the type of restriction can be
 * passed as well.
 *
 * @param {String} containerId The container id
 * @param {String} [restrict] The container restriction defaulted to `'self-only'`
 * @returns {Boolean} `true` if the container has the specified restriction
 * @private
 */


function isRestrictedContainer(containerId) {
  var restrict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'self-only';
  var config = getContainerConfig(containerId);
  return Boolean(config && config.restrict === restrict);
}
/**
 * Determines if `innerContainerId` is inside `outerContainerId`.
 *
 * @param {String} outerContainerId The outer container id
 * @param {String} innerContainerId The inner container id
 * @returns {Boolean} `true` if both containers exist and `innerContainerId` is within
 *                    `outerContainerId`
 * @private
 */


function containsContainer(outerContainerId, innerContainerId) {
  var outer = getContainerNode(outerContainerId);
  var inner = getContainerNode(innerContainerId);
  return Boolean(outer && inner && outer.contains(inner));
}
/**
 * Determines if `containerId` may become the active container.
 *
 * @param {String} containerId Spotlight container to which focus is leaving
 * @returns	{Boolean} `true` if the active container can change to `containerId`
 * @private
 */


function mayActivateContainer(containerId) {
  var currentContainerId = getLastContainer(); // If the current container or its outer containers are restricted to 'self-only' and
  // if the next container to be activated is not inside the restrict container,
  // the next container should not be activated.

  var currentContainerNode = getContainerNode(currentContainerId);
  var restrictContainer = getContainersForNode(currentContainerNode).reduceRight(function (result, outerContainerId) {
    return result || (isRestrictedContainer(outerContainerId) ? outerContainerId : null);
  }, null);
  return !restrictContainer || containsContainer(restrictContainer, containerId);
}

function getDefaultContainer() {
  return isActiveContainer(_defaultContainerId) ? _defaultContainerId : '';
}

function setDefaultContainer(containerId) {
  if (!containerId) {
    _defaultContainerId = '';
  } else if (!getContainerConfig(containerId)) {
    throw new Error('Container "' + containerId + '" doesn\'t exist!');
  } else {
    _defaultContainerId = containerId;
  }
}

function getLastContainer() {
  return isActiveContainer(_lastContainerId) ? _lastContainerId : '';
}

function setLastContainer(containerId) {
  _lastContainerId = containerId || '';
}
/**
 * Updates the last container based on the current focus and target focus.
 *
 * @param {Node} current Currently focused node
 * @param {Node} target  Target node. May or may not be focusable
 * @memberof spotlight/container
 * @public
 */


function setLastContainerFromTarget(current, target) {
  var currentContainers = getNavigableContainersForNode(current);
  var currentOuterContainerId = currentContainers[0];
  var currentContainerConfig = getContainerConfig(currentOuterContainerId);
  var targetContainers = getContainersForNode(target);
  var targetInnerContainer = (0, _last["default"])(targetContainers);
  var sharedContainer = (0, _last["default"])((0, _intersection["default"])(currentContainers, targetContainers));

  if (sharedContainer || !currentContainerConfig || currentContainerConfig.restrict !== 'self-only') {
    // If the target shares a container with the current container stack or the current
    // element isn't within a self-only container, use the target's nearest container
    setLastContainer(targetInnerContainer);
  } else {
    // Otherwise, the target is not within the current container stack and the current
    // element was within a 'self-only' container, use the current's outer container
    setLastContainer(currentOuterContainerId);
  }
}

function isWithinOverflowContainer(target) {
  var containerIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getContainersForNode(target);
  return containerIds // ignore the root container id which is set to overflow by the root decorator
  .filter(function (id) {
    return id !== rootContainerId;
  }) // get the config for each container
  .map(getContainerConfig) // and check if any are set to overflow
  .some(function (config) {
    return config && config.overflow;
  });
}
/**
 * Notifies any affected containers that focus has left one of their children for another container
 *
 * @param {String} direction up/down/left/right
 * @param {Node} current currently focused element
 * @param {String[]} currentContainerIds Containers for current
 * @param {Node} next To be focused element
 * @param {String[]} nextContainerIds Containers for next
 * @private
 */


function notifyLeaveContainer(direction, current, currentContainerIds, next, nextContainerIds) {
  currentContainerIds.forEach(function (containerId) {
    if (!nextContainerIds.includes(containerId)) {
      var config = getContainerConfig(containerId);

      if (config && config.onLeaveContainer) {
        config.onLeaveContainer({
          type: 'onLeaveContainer',
          direction: direction,
          target: current,
          relatedTarget: next
        });
      }
    }
  });
}
/**
 * Notifies any containers that focus attempted to move but failed to find a target
 *
 * @param {String} direction up/down/left/right
 * @param {Node} current currently focused element
 * @param {String[]} currentContainerIds Containers for current
 * @private
 */


function notifyLeaveContainerFail(direction, current, currentContainerIds) {
  currentContainerIds.forEach(function (containerId) {
    var config = getContainerConfig(containerId);

    if (config && config.onLeaveContainerFail) {
      config.onLeaveContainerFail({
        type: 'onLeaveContainerFail',
        direction: direction,
        target: current
      });
    }
  });
}
/**
 * Notifies any affected containers that one of their children has received focus.
 *
 * @param {String} direction up/down/left/right
 * @param {Node} previous Previously focused element
 * @param {String[]} previousContainerIds Containers for previous
 * @param {Node} current Currently focused element
 * @param {String[]} currentContainerIds Containers for current
 * @private
 */


function notifyEnterContainer(direction, previous, previousContainerIds, current, currentContainerIds) {
  currentContainerIds.forEach(function (containerId) {
    if (!previousContainerIds.includes(containerId)) {
      var config = getContainerConfig(containerId);

      if (config && config.onEnterContainer) {
        config.onEnterContainer({
          type: 'onEnterContainer',
          direction: direction,
          target: current,
          relatedTarget: previous
        });
      }
    }
  });
}