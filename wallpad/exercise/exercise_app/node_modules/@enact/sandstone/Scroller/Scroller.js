"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.Scroller = void 0;

var _I18nDecorator = require("@enact/i18n/I18nDecorator");

var _SpotlightContainerDecorator = _interopRequireDefault(require("@enact/spotlight/SpotlightContainerDecorator"));

var _Spottable = _interopRequireDefault(require("@enact/spotlight/Spottable"));

var _Resizable = require("@enact/ui/Resizable");

var _Scroller = require("@enact/ui/Scroller");

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = require("react");

var _useScroll2 = _interopRequireDefault(require("../useScroll"));

var _HoverToScroll = _interopRequireDefault(require("../useScroll/HoverToScroll"));

var _Scrollbar = _interopRequireDefault(require("../useScroll/Scrollbar"));

var _ScrollbarPlaceholder = _interopRequireDefault(require("../useScroll/ScrollbarPlaceholder"));

var _Skinnable = _interopRequireDefault(require("../Skinnable"));

var _EditableWrapper = require("./EditableWrapper");

var _useThemeScroller2 = _interopRequireDefault(require("./useThemeScroller"));

var _jsxRuntime = require("react/jsx-runtime");

var _excluded = ["aria-label", "hoverToScroll"],
    _excluded2 = ["className"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var nop = function nop() {};

var SpottableDiv = (0, _Spottable["default"])('div');
var scrollerId = 0;
/**
 * A Sandstone-styled Scroller, useScroll applied.
 *
 * Usage:
 * ```
 * <Scroller>Scroll me.</Scroller>
 * ```
 *
 * @class Scroller
 * @memberof sandstone/Scroller
 * @extends ui/Scroller.ScrollerBasic
 * @ui
 * @public
 */

var Scroller = function Scroller(_ref) {
  var ariaLabel = _ref['aria-label'],
      hoverToScroll = _ref.hoverToScroll,
      rest = _objectWithoutProperties(_ref, _excluded);

  var id = "scroller_".concat(++scrollerId, "_content"); // Hooks

  var _useScroll = (0, _useScroll2["default"])(rest),
      ScrollContentWrapper = _useScroll.scrollContentWrapper,
      scrollContentHandle = _useScroll.scrollContentHandle,
      isHorizontalScrollbarVisible = _useScroll.isHorizontalScrollbarVisible,
      isVerticalScrollbarVisible = _useScroll.isVerticalScrollbarVisible,
      resizeContextProps = _useScroll.resizeContextProps,
      scrollContainerProps = _useScroll.scrollContainerProps,
      scrollContentWrapperProps = _useScroll.scrollContentWrapperProps,
      scrollContentProps = _useScroll.scrollContentProps,
      horizontalScrollbarProps = _useScroll.horizontalScrollbarProps,
      verticalScrollbarProps = _useScroll.verticalScrollbarProps,
      hoverToScrollProps = _useScroll.hoverToScrollProps;

  var className = scrollContentWrapperProps.className,
      scrollContentWrapperRest = _objectWithoutProperties(scrollContentWrapperProps, _excluded2);

  var _useThemeScroller = (0, _useThemeScroller2["default"])(rest, _objectSpread(_objectSpread({}, scrollContentProps), {}, {
    className: (0, _classnames["default"])(className, scrollContentProps.className)
  }), id, isHorizontalScrollbarVisible, isVerticalScrollbarVisible),
      editableWrapperProps = _useThemeScroller.editableWrapperProps,
      focusableBodyProps = _useThemeScroller.focusableBodyProps,
      themeScrollContentProps = _useThemeScroller.themeScrollContentProps;

  var children = rest.children,
      direction = rest.direction,
      editable = rest.editable; // To apply spotlight navigableFilter, SpottableDiv should be in scrollContainer.

  var ScrollBody = rest.focusableScrollbar === 'byEnter' ? SpottableDiv : _react.Fragment; // Render

  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Resizable.ResizeContext.Provider, _objectSpread(_objectSpread({}, resizeContextProps), {}, {
    children: /*#__PURE__*/(0, _jsxRuntime.jsx)(ScrollContentWrapper, _objectSpread(_objectSpread(_objectSpread({}, scrollContainerProps), scrollContentWrapperRest), {}, {
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(ScrollBody, _objectSpread(_objectSpread({}, focusableBodyProps), {}, {
        children: [rest.focusableScrollbar ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_ScrollbarPlaceholder["default"], {}) : null, /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scroller.ScrollerBasic, _objectSpread(_objectSpread({}, themeScrollContentProps), {}, {
          "aria-label": ariaLabel,
          id: id,
          ref: scrollContentHandle,
          children: editable && direction === 'horizontal' ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_EditableWrapper.EditableWrapper, _objectSpread({}, editableWrapperProps)) : children
        })), isVerticalScrollbarVisible ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scrollbar["default"], _objectSpread({}, verticalScrollbarProps)) : null, isHorizontalScrollbarVisible ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scrollbar["default"], _objectSpread({}, horizontalScrollbarProps)) : null, hoverToScroll ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_HoverToScroll["default"], _objectSpread({}, hoverToScrollProps)) : null]
      }))
    }))
  }));
};

exports.Scroller = Scroller;
Scroller.displayName = 'Scroller';
Scroller.propTypes =
/** @lends sandstone/Scroller.Scroller.prototype */
{
  /**
   * The "aria-label" for the Scroller.
   *
   * When `aria-label` is set and `focusableScrollbar` is `byEnter`, it will be used
   * instead to provide an accessibility label for the Scroller.
   *
   * @type {String}
   * @public
   */
  'aria-label': _propTypes["default"].string,

  /**
   * A callback function that receives a reference to the `scrollTo` feature.
   *
   * Once received, the `scrollTo` method can be called as an imperative interface.
   *
   * - {position: {x, y}} - Pixel value for x and/or y position
   * - {align} - Where the scroll area should be aligned. Values are:
   *   `'left'`, `'right'`, `'top'`, `'bottom'`,
   *   `'topleft'`, `'topright'`, `'bottomleft'`, and `'bottomright'`.
   * - {node} - Node to scroll into view
   * - {animate} - When `true`, scroll occurs with animation. When `false`, no
   *   animation occurs.
   * - {focus} - When `true`, attempts to focus item after scroll. Only valid when scrolling
   *   by `node`.
   * > Note: Only specify one of: `position`, `align`, `node`
   *
   * Example:
   * ```
   *	// If you set cbScrollTo prop like below;
   *	cbScrollTo: (fn) => {this.scrollTo = fn;}
   *	// You can simply call like below;
   *	this.scrollTo({align: 'top'}); // scroll to the top
   * ```
   *
   * @type {Function}
   * @public
   */
  cbScrollTo: _propTypes["default"].func,

  /**
   * This is set to `true` by SpotlightContainerDecorator
   *
   * @type {Boolean}
   * @private
   */
  'data-spotlight-container': _propTypes["default"].bool,

  /**
   * `false` if the content of the scroller could get focus
   *
   * @type {Boolean}
   * @default false
   * @private
   */
  'data-spotlight-container-disabled': _propTypes["default"].bool,

  /**
   * This is passed onto the wrapped component to allow
   * it to customize the spotlight container for its use case.
   *
   * @type {String}
   * @private
   */
  'data-spotlight-id': _propTypes["default"].string,

  /**
   * Disable voice control feature of component.
   *
   * @type {Boolean}
   * @public
   */
  'data-webos-voice-disabled': _propTypes["default"].bool,

  /**
   * Activates the component for voice control.
   *
   * @type {Boolean}
   * @public
   */
  'data-webos-voice-focused': _propTypes["default"].bool,

  /**
   * The voice control group label.
   *
   * @type {String}
   * @public
   */
  'data-webos-voice-group-label': _propTypes["default"].string,

  /**
   * Direction of the scroller.
   *
   * @type {('both'|'horizontal'|'vertical')}
   * @default 'both'
   * @public
   */
  direction: _propTypes["default"].oneOf(['both', 'horizontal', 'vertical']),

  /**
   * Enables editing items in the scroller.
   * You can specify props for editable scroller as an object.
   * See the details in [EditableShape]{@link sandstone/Scroller.EditableShape}
   *
   * @type {sandstone/Scroller.EditableShape}
   * @public
   */
  editable: _EditableWrapper.EditableShape,

  /**
   * Adds fade-out effect on the scroller.
   *
   * Set this to `true` only if the content has no spottable but text.
   * > Note: Fade-out effect will not show if the `direction` is set to `both`.
   *
   * @type {Boolean}
   * @default false
   * @public
   */
  fadeOut: _propTypes["default"].bool,

  /**
   * Allows 5-way navigation to the scroll thumb.
   *
   * By default, 5-way will not move focus to the scroll thumb.
   * If `true`, the scroll thumb will get focus by directional keys.
   * If `'byEnter'`, scroll thumb will get focus first by directional keys,
   * then the scroll body will get focus by enter key or back key pressed on scroll thumb.
   *
   * @type {Boolean|'byEnter'}
   * @default false
   * @public
   */
  focusableScrollbar: _propTypes["default"].oneOfType([_propTypes["default"].bool, _propTypes["default"].oneOf(['byEnter'])]),

  /**
   * Specifies how to show horizontal scrollbar.
   *
   * @type {('auto'|'visible'|'hidden')}
   * @default 'auto'
   * @public
   */
  horizontalScrollbar: _propTypes["default"].oneOf(['auto', 'visible', 'hidden']),

  /**
   * Sets the hint string read when focusing the scroll thumb in the horizontal scroll bar.
   *
   * @type {String}
   * @default $L('scroll up or down with up down button')
   * @public
   */
  horizontalScrollThumbAriaLabel: _propTypes["default"].string,

  /**
   * Enables scroll by hover on edges in scroll direction.
   *
   * @type {Boolean}
   * @public
   */
  hoverToScroll: _propTypes["default"].bool,

  /**
   * Unique identifier for the component.
   *
   * When defined and when the `Scroller` is within a [Panel]{@link sandstone/Panels.Panel}, the
   * `Scroller` will store its scroll position and restore that position when returning to the
   * `Panel`.
   *
   * @type {String}
   * @public
   */
  id: _propTypes["default"].string,

  /**
   * Prevents scroll by dragging or flicking on the scroller.
   *
   * @type {Boolean}
   * @default false
   * @private
   */
  noScrollByDrag: _propTypes["default"].bool,

  /**
   * Prevents scroll by wheeling on the scroller.
   *
   * @type {Boolean}
   * @default false
   * @public
   */
  noScrollByWheel: _propTypes["default"].bool,

  /**
   * Called when scrolling.
   *
   * Passes `scrollLeft`, `scrollTop`.
   * It is not recommended to set this prop since it can cause performance degradation.
   * Use `onScrollStart` or `onScrollStop` instead.
   *
   * @type {Function}
   * @param {Object} event
   * @param {Number} event.scrollLeft Scroll left value.
   * @param {Number} event.scrollTop Scroll top value.
   * @public
   */
  onScroll: _propTypes["default"].func,

  /**
   * Called when scroll starts.
   *
   * Passes `scrollLeft` and `scrollTop`.
   *
   * Example:
   * ```
   * onScrollStart = ({scrollLeft, scrollTop}) => {
   *     // do something with scrollLeft and scrollTop
   * }
   *
   * render = () => (
   *     <Scroller
   *         ...
   *         onScrollStart={this.onScrollStart}
   *         ...
   *     />
   * )
   * ```
   *
   * @type {Function}
   * @param {Object} event
   * @param {Number} event.scrollLeft Scroll left value.
   * @param {Number} event.scrollTop Scroll top value.
   * @public
   */
  onScrollStart: _propTypes["default"].func,

  /**
   * Called when scroll stops.
   *
   * Passes `scrollLeft` and `scrollTop`.
   *
   * Example:
   * ```
   * onScrollStop = ({scrollLeft, scrollTop}) => {
   *     // do something with scrollLeft and scrollTop
   * }
   *
   * render = () => (
   *     <Scroller
   *         ...
   *         onScrollStop={this.onScrollStop}
   *         ...
   *     />
   * )
   * ```
   *
   * @type {Function}
   * @param {Object} event
   * @param {Number} event.scrollLeft Scroll left value.
   * @param {Number} event.scrollTop Scroll top value.
   * @public
   */
  onScrollStop: _propTypes["default"].func,

  /**
   * Specifies overscroll effects shows on which type of inputs.
   *
   * @type {Object}
   * @default {
   *	arrowKey: false,
   *	drag: true,
   *	pageKey: false,
   *	track: false,
   *	wheel: true
   * }
   * @private
   */
  overscrollEffectOn: _propTypes["default"].shape({
    arrowKey: _propTypes["default"].bool,
    drag: _propTypes["default"].bool,
    pageKey: _propTypes["default"].bool,
    track: _propTypes["default"].bool,
    wheel: _propTypes["default"].bool
  }),

  /**
   * Customizes the component by mapping the supplied collection of CSS class names to the
   * corresponding internal elements and states of this component.
   *
   * The following classes are supported:
   *
   * * `scrollbarTrack` - The scrollbarTrack component class
   * * `thumb` - The scrollbar thumb component class
   *
   * @type {Object}
   * @public
   */
  scrollbarTrackCss: _propTypes["default"].object,

  /**
   * Specifies how to scroll.
   *
   * @type {('native'|'translate')}
   * @default 'native'
   * @public
   */
  scrollMode: _propTypes["default"].oneOf(['native', 'translate']),

  /**
   * Specifies how to show vertical scrollbar.
   *
   * @type {('auto'|'visible'|'hidden')}
   * @default 'auto'
   * @public
   */
  verticalScrollbar: _propTypes["default"].oneOf(['auto', 'visible', 'hidden']),

  /**
   * Sets the hint string read when focusing the scroll thumb in the vertical scroll bar.
   *
   * @type {String}
   * @default $L('scroll left or right with left right button')
   * @public
   */
  verticalScrollThumbAriaLabel: _propTypes["default"].string
};
exports.Scroller = Scroller = (0, _Skinnable["default"])((0, _SpotlightContainerDecorator["default"])({
  overflow: true,
  preserveId: true,
  restrict: 'self-first'
}, (0, _I18nDecorator.I18nContextDecorator)({
  rtlProp: 'rtl'
}, Scroller)));
Scroller.defaultProps = {
  'data-spotlight-container-disabled': false,
  cbScrollTo: nop,
  direction: 'both',
  fadeOut: false,
  focusableScrollbar: false,
  horizontalScrollbar: 'auto',
  noScrollByDrag: false,
  noScrollByWheel: false,
  onScroll: nop,
  onScrollStart: nop,
  onScrollStop: nop,
  overscrollEffectOn: {
    arrowKey: false,
    drag: true,
    pageKey: false,
    track: false,
    wheel: true
  },
  scrollMode: 'native',
  verticalScrollbar: 'auto'
};
var _default = Scroller;
exports["default"] = _default;