"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.EditableWrapper = exports.EditableShape = void 0;

var _handle = require("@enact/core/handle");

var _propTypes = _interopRequireDefault(require("@enact/core/internal/prop-types"));

var _keymap = require("@enact/core/keymap");

var _util = require("@enact/core/util");

var _spotlight = _interopRequireDefault(require("@enact/spotlight"));

var _Accelerator = _interopRequireDefault(require("@enact/spotlight/Accelerator"));

var _AnnounceDecorator = require("@enact/ui/AnnounceDecorator");

var _Touchable = _interopRequireDefault(require("@enact/ui/Touchable"));

var _classnames = _interopRequireDefault(require("classnames"));

var _IString = _interopRequireDefault(require("ilib/lib/IString"));

var _propTypes2 = _interopRequireDefault(require("prop-types"));

var _react = require("react");

var _$L = _interopRequireDefault(require("../internal/$L"));

var _EditableWrapperModule = _interopRequireDefault(require("./EditableWrapper.module.css"));

var _jsxRuntime = require("react/jsx-runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var completeAnnounceDelay = 300; // An arbitrary delay at a level that is not ignored by the new focus element

var TouchableDiv = (0, _Touchable["default"])('div');
/**
 * The shape for editable of [Scroller]{@link sandstone/Scroller}.
 *
 * @typedef {Object} EditableShape
 * @memberof sandstone/Scroller
 * @property {Function} onComplete The callback function called when editing is finished.
 *  It has an event object contains `orders` array which app can use for repopulate items.
 * @property {Boolean} [centered] Centers the contents of the scroller.
 * @property {Object} [css] Customizes the component by mapping the supplied collection of CSS class names to the
 *  corresponding internal elements and states of this component.
 *  The following classes are supported:
 *
 * * `wrapper` - The content wrapper component class
 * * `selected` - The selected item class
 * @property {Function|Object} [removeItemFuncRef] Obtains a reference to `removeItem` function.
 *  If you would like to remove an item, you can get the reference to `removeItem` function via `useRef`.
 * @public
 */

var EditableShape = _propTypes2["default"].shape({
  onComplete: _propTypes2["default"].func.isRequired,
  centered: _propTypes2["default"].bool,
  css: _propTypes2["default"].object,
  removeItemFuncRef: _propTypes["default"].ref
});

exports.EditableShape = EditableShape;
var SpotlightAccelerator = new _Accelerator["default"]([5, 4]);
var holdDuration = 500;
var holdConfig = {
  events: [{
    name: 'hold',
    time: holdDuration
  }]
};
/**
 * A Sandstone-styled EditableWrapper.
 *
 * @class EditableWrapper
 * @memberof sandstone/Scroller
 * @ui
 * @public
 */

var EditableWrapper = function EditableWrapper(props) {
  var children = props.children,
      editable = props.editable,
      scrollContainerHandle = props.scrollContainerHandle,
      scrollContainerRef = props.scrollContainerRef,
      scrollContentRef = props.scrollContentRef;
  var centered = (editable === null || editable === void 0 ? void 0 : editable.centered) != null ? editable.centered : true;
  var customCss = (editable === null || editable === void 0 ? void 0 : editable.css) || {};
  var removeItemFuncRef = editable === null || editable === void 0 ? void 0 : editable.removeItemFuncRef;
  var mergedCss = (0, _util.mergeClassNameMaps)(_EditableWrapperModule["default"], customCss, Object.keys(_EditableWrapperModule["default"]));
  var dataSize = children === null || children === void 0 ? void 0 : children.length; // Mutable value

  var wrapperRef = (0, _react.useRef)();
  var mutableRef = (0, _react.useRef)({
    // Constants
    itemWidth: null,
    centeredOffset: 0,
    spotlightId: null,
    // DOM elements
    selectedItem: null,
    selectedItemLabel: '',
    rearrangedItems: [],
    // Indices
    fromIndex: null,
    prevToIndex: null,
    // Position for restoring focus after removing item
    nextSpotlightRect: null,
    // Last move direction
    lastMoveDirection: null,
    // Last mouse position
    lastMouseClientX: null,
    // Last InputType which moves Items
    lastInputType: null,
    // Timer for holding key input
    keyHoldTimerId: null,
    // Flag for prevent event propagation
    needToPreventEvent: null,
    lastInputDirection: null
  });
  var announceRef = (0, _react.useRef)({}); // Functions
  // Reset values

  var reset = (0, _react.useCallback)(function () {
    var _mutableRef$current = mutableRef.current,
        selectedItem = _mutableRef$current.selectedItem,
        spotlightId = _mutableRef$current.spotlightId;
    selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.classList.remove(_EditableWrapperModule["default"].selected, customCss.selected, _EditableWrapperModule["default"].rearranged);
    mutableRef.current.selectedItem = null;
    mutableRef.current.selectedItemLabel = '';
    mutableRef.current.lastMoveDirection = null;
    mutableRef.current.prevToIndex = null;
    wrapperRef.current.style.setProperty('--selected-item-offset', '0px');

    _spotlight["default"].set(spotlightId, {
      restrict: 'self-first'
    });
  }, [customCss.selected]); // Finalize the order

  var finalizeOrders = (0, _react.useCallback)(function () {
    var _mutableRef$current2 = mutableRef.current,
        fromIndex = _mutableRef$current2.fromIndex,
        lastMoveDirection = _mutableRef$current2.lastMoveDirection,
        prevToIndex = _mutableRef$current2.prevToIndex,
        rearrangedItems = _mutableRef$current2.rearrangedItems,
        selectedItem = _mutableRef$current2.selectedItem;
    var orders = Array.from({
      length: dataSize
    }, function (_, i) {
      return i + 1;
    });

    if (rearrangedItems.length > 0) {
      var selectedOrder = selectedItem.style.order;
      var changedOrder = [];
      rearrangedItems.forEach(function (item) {
        var order = Number(item.style.order);
        selectedOrder = order;
        item.style.order = order - lastMoveDirection;
        item.classList.remove(_EditableWrapperModule["default"].rearrangedTransform, _EditableWrapperModule["default"].rearranged);

        if (lastMoveDirection > 0) {
          changedOrder.push(order);
        } else {
          changedOrder.unshift(order);
        }
      });

      if (lastMoveDirection > 0) {
        changedOrder.push(Number(selectedItem.style.order));
      } else {
        changedOrder.unshift(Number(selectedItem.style.order));
      }

      mutableRef.current.rearrangedItems = [];
      selectedItem.style.order = selectedOrder; // Create reordered array

      orders.splice.apply(orders, [Math.min(fromIndex, prevToIndex), changedOrder.length].concat(changedOrder));
    }

    return orders;
  }, [dataSize]);
  var startEditing = (0, _react.useCallback)(function (item) {
    if (item.dataset.index) {
      _spotlight["default"].set(mutableRef.current.spotlightId, {
        restrict: 'self-only'
      });

      item.classList.add(_EditableWrapperModule["default"].selected, customCss.selected);
      mutableRef.current.selectedItem = item;
      mutableRef.current.selectedItemLabel = (item.ariaLabel || item.textContent) + ' ';
      mutableRef.current.fromIndex = Number(item.style.order) - 1;
      mutableRef.current.prevToIndex = mutableRef.current.fromIndex;
      announceRef.current.announce(mutableRef.current.selectedItemLabel + (0, _$L["default"])('Move left and right or press up key to delete'));
    }
  }, [customCss.selected]);
  var findItemNode = (0, _react.useCallback)(function (node) {
    for (var current = node; current !== scrollContentRef.current && current !== document; current = current.parentNode) {
      if (current.dataset.index) {
        return current;
      }
    }
  }, [scrollContentRef]);
  var handleClickCapture = (0, _react.useCallback)(function (ev) {
    if (ev.target.className.includes('Button')) {
      return;
    } // Consume the event to prevent Item behavior


    if (mutableRef.current.selectedItem || mutableRef.current.needToPreventEvent) {
      ev.preventDefault();
      ev.stopPropagation();
      mutableRef.current.needToPreventEvent = false;
    }
  }, []);
  var handleMouseDown = (0, _react.useCallback)(function (ev) {
    if (ev.target.className.includes('Button')) {
      return;
    }

    if (mutableRef.current.selectedItem) {
      // Finalize orders and forward `onComplete` event
      var orders = finalizeOrders();
      (0, _handle.forwardCustom)('onComplete', function () {
        return {
          orders: orders
        };
      })({}, editable);
      reset();
      mutableRef.current.needToPreventEvent = true;
    } else {
      mutableRef.current.targetItemNode = findItemNode(ev.target);
      mutableRef.current.needToPreventEvent = false;
    }
  }, [editable, finalizeOrders, findItemNode, reset]);
  var handleHoldStart = (0, _react.useCallback)(function () {
    var targetItemNode = mutableRef.current.targetItemNode;

    if (targetItemNode && targetItemNode.dataset.index) {
      // Start editing by adding selected transition to selected item
      startEditing(targetItemNode);
    }
  }, [startEditing]);
  var readOutCurrentPosition = (0, _react.useCallback)(function (neighborItem) {
    var _mutableRef$current3 = mutableRef.current,
        lastInputDirection = _mutableRef$current3.lastInputDirection,
        lastInputType = _mutableRef$current3.lastInputType,
        selectedItemLabel = _mutableRef$current3.selectedItemLabel;

    if (lastInputType === 'key') {
      if (lastInputDirection === 'left') {
        announceRef.current.announce(new _IString["default"]((0, _$L["default"])('{selectedItem} moved to the left of {neighborItem}')).format({
          selectedItem: selectedItemLabel,
          neighborItem: neighborItem
        }), true);
      } else {
        announceRef.current.announce(new _IString["default"]((0, _$L["default"])('{selectedItem} moved to the right of {neighborItem}')).format({
          selectedItem: selectedItemLabel,
          neighborItem: neighborItem
        }), true);
      }
    }
  }, []); // Add rearranged items

  var addRearrangedItems = (0, _react.useCallback)(function (_ref) {
    var moveDirection = _ref.moveDirection,
        toIndex = _ref.toIndex;
    // Set the moveDirection to css variable
    var rtl = scrollContainerHandle.current.rtl;
    wrapperRef.current.style.setProperty('--move-direction', moveDirection * (rtl ? -1 : 1));
    var _mutableRef$current4 = mutableRef.current,
        fromIndex = _mutableRef$current4.fromIndex,
        rearrangedItems = _mutableRef$current4.rearrangedItems,
        selectedItem = _mutableRef$current4.selectedItem;

    var getNextElement = function getNextElement(item) {
      return moveDirection > 0 ? item.nextElementSibling : item.previousElementSibling;
    };

    var sibling = getNextElement(selectedItem);
    var lastRearrangedItem;
    var start = moveDirection > 0 ? toIndex : fromIndex;
    var end = moveDirection > 0 ? fromIndex : toIndex;

    while (start > end && sibling) {
      var _sibling;

      (_sibling = sibling) === null || _sibling === void 0 ? void 0 : _sibling.classList.add(_EditableWrapperModule["default"].rearranged, _EditableWrapperModule["default"].rearrangedTransform);

      if (!rearrangedItems.includes(sibling)) {
        rearrangedItems.push(sibling);
      }

      lastRearrangedItem = sibling;
      sibling = getNextElement(sibling);
      start--;
    }

    if (lastRearrangedItem) {
      readOutCurrentPosition(lastRearrangedItem.ariaLabel || lastRearrangedItem.textContent);
    }

    mutableRef.current.lastMoveDirection = moveDirection;
  }, [readOutCurrentPosition, scrollContainerHandle]);
  var removeRearrangedItems = (0, _react.useCallback)(function (numToRemove) {
    var rearrangedItems = mutableRef.current.rearrangedItems;
    var toItem = null;

    if (rearrangedItems.length > 0) {
      for (var i = 0; i < numToRemove; i++) {
        var _toItem;

        toItem = rearrangedItems.pop();
        (_toItem = toItem) === null || _toItem === void 0 ? void 0 : _toItem.classList.remove(_EditableWrapperModule["default"].rearrangedTransform);
      }
    }

    if (toItem) {
      readOutCurrentPosition(toItem.ariaLabel || toItem.textContent);
    }
  }, [readOutCurrentPosition]); // Move items

  var moveItems = (0, _react.useCallback)(function (toIndex) {
    var selectedItem = mutableRef.current.selectedItem;
    var rtl = scrollContainerHandle.current.rtl;

    if (selectedItem) {
      // Bail out when index is out of scope
      if (toIndex < dataSize && toIndex >= 0) {
        var _mutableRef$current5 = mutableRef.current,
            fromIndex = _mutableRef$current5.fromIndex,
            itemWidth = _mutableRef$current5.itemWidth,
            lastMoveDirection = _mutableRef$current5.lastMoveDirection,
            prevToIndex = _mutableRef$current5.prevToIndex,
            rearrangedItems = _mutableRef$current5.rearrangedItems; // Set the selected item's offset to css variable

        var offset = (toIndex - fromIndex) * itemWidth;
        wrapperRef.current.style.setProperty('--selected-item-offset', offset * (rtl ? -1 : 1) + 'px'); // If the current toIndex is new,

        if (toIndex !== prevToIndex) {
          // Determine the direction of move from the latest from index
          var moveDirection = Math.sign(toIndex - prevToIndex); // If the direction is changed and there are rearranged items, we remove them first.

          if (lastMoveDirection && moveDirection !== lastMoveDirection && rearrangedItems.length > 0) {
            var numToRemove = moveDirection > 0 ? toIndex - prevToIndex : prevToIndex - toIndex;
            removeRearrangedItems(numToRemove); // When there's jump, meaning, numToRemove is bigger than 0, we need to add an item

            if (numToRemove > rearrangedItems.length) {
              addRearrangedItems({
                moveDirection: moveDirection,
                toIndex: toIndex
              });
            }
          } else {
            addRearrangedItems({
              moveDirection: moveDirection,
              toIndex: toIndex
            });
          }

          mutableRef.current.prevToIndex = toIndex;
        }
      }
    }
  }, [dataSize, addRearrangedItems, removeRearrangedItems, scrollContainerHandle]);
  var moveItemsByKeyDown = (0, _react.useCallback)(function (ev) {
    var keyCode = ev.keyCode;
    var container = scrollContentRef.current;
    var _mutableRef$current6 = mutableRef.current,
        itemWidth = _mutableRef$current6.itemWidth,
        prevToIndex = _mutableRef$current6.prevToIndex;
    var rtl = scrollContainerHandle.current.rtl;
    var toIndex = !rtl ^ !(0, _keymap.is)('left', keyCode) ? prevToIndex - 1 : prevToIndex + 1;
    var scrollLeft = container.scrollLeft * (rtl ? -1 : 1);
    var itemLeft = toIndex * itemWidth - scrollLeft;
    var left;

    if (itemLeft > container.offsetLeft + container.clientWidth - itemWidth) {
      left = itemLeft - (container.clientWidth - itemWidth) + scrollLeft;
    } else if (itemLeft < 0) {
      left = scrollLeft + itemLeft;
    }

    if (left != null) {
      /* avoid null or undefined */
      scrollContainerHandle.current.start({
        targetX: left,
        targetY: 0
      });
    }

    mutableRef.current.lastInputType = 'key';
    mutableRef.current.lastInputDirection = (0, _keymap.is)('left', keyCode) ? 'left' : 'right';
    moveItems(toIndex);

    if (toIndex <= 0) {
      announceRef.current.announce((0, _keymap.is)('left', keyCode) && !rtl && (0, _$L["default"])('LEFTMOST') || (0, _keymap.is)('right', keyCode) && rtl && (0, _$L["default"])('RIGHTMOST'));
    } else if (toIndex >= dataSize - 1) {
      announceRef.current.announce((0, _keymap.is)('right', keyCode) && !rtl && (0, _$L["default"])('RIGHTMOST') || (0, _keymap.is)('left', keyCode) && rtl && (0, _$L["default"])('LEFTMOST'));
    }
  }, [dataSize, moveItems, scrollContainerHandle, scrollContentRef]); // Remove an item

  var removeItem = (0, _react.useCallback)(function () {
    var _mutableRef$current7 = mutableRef.current,
        prevToIndex = _mutableRef$current7.prevToIndex,
        selectedItem = _mutableRef$current7.selectedItem;

    if (selectedItem) {
      var selectedItemRect = selectedItem && selectedItem.getBoundingClientRect();
      mutableRef.current.nextSpotlightRect = {
        x: selectedItemRect.right,
        y: selectedItemRect.top
      };
      var orders = finalizeOrders();
      orders.splice(prevToIndex, 1);
      (0, _handle.forwardCustom)('onComplete', function () {
        return {
          orders: orders
        };
      })({}, editable);
      reset();
    }
  }, [editable, finalizeOrders, reset]);
  var getNextIndexFromPosition = (0, _react.useCallback)(function (x, tolerance) {
    var _mutableRef$current8 = mutableRef.current,
        centeredOffset = _mutableRef$current8.centeredOffset,
        itemWidth = _mutableRef$current8.itemWidth,
        prevToIndex = _mutableRef$current8.prevToIndex;
    var rtl = scrollContainerHandle.current.rtl;
    var bodyWidth = document.body.getBoundingClientRect().width; // Determine toIndex with mouse client x position
    // Coordinate calculation in RTL locales is not supported in chrome below 85

    var scrollContentOffset = scrollContentRef.current.scrollLeft * (rtl ? -1 : 1) - centeredOffset;
    var clientXFromContent = (rtl ? bodyWidth - x : x) + scrollContentOffset;
    var moveDirection = itemWidth * (prevToIndex + 0.5) < clientXFromContent ? 1 : -1; // 1: To next index , -1: To prev index

    var moveTolerance = itemWidth * tolerance * moveDirection;
    return Math.floor((clientXFromContent - moveTolerance) / itemWidth);
  }, [scrollContainerHandle, scrollContentRef]);
  var handleMouseMove = (0, _react.useCallback)(function (ev) {
    if (mutableRef.current.selectedItem) {
      var clientX = ev.clientX;
      var toIndex = getNextIndexFromPosition(clientX, 0.33);
      mutableRef.current.lastMouseClientX = clientX;
      mutableRef.current.lastInputType = 'mouse';
      moveItems(toIndex);
    }
  }, [getNextIndexFromPosition, moveItems]);
  var handleMouseLeave = (0, _react.useCallback)(function () {
    var _mutableRef$current9 = mutableRef.current,
        itemWidth = _mutableRef$current9.itemWidth,
        lastInputType = _mutableRef$current9.lastInputType,
        lastMouseClientX = _mutableRef$current9.lastMouseClientX,
        selectedItem = _mutableRef$current9.selectedItem;
    var rtl = scrollContainerHandle.current.rtl;
    var scrollContentNode = scrollContentRef.current;
    var scrollContentCenter = scrollContentNode.getBoundingClientRect().width / 2;

    if (selectedItem) {
      var orders = finalizeOrders();
      (0, _handle.forwardCustom)('onComplete', function () {
        return {
          orders: orders
        };
      })({}, editable);
      reset();

      if (lastInputType === 'scroll') {
        var offset = itemWidth * (!rtl ^ !(lastMouseClientX > scrollContentCenter) ? 1 : -1);
        scrollContainerHandle.current.start({
          targetX: scrollContentNode.scrollLeft + offset,
          targetY: 0
        });
      }
    }
  }, [editable, finalizeOrders, reset, scrollContainerHandle, scrollContentRef]);
  var handleKeyDownCapture = (0, _react.useCallback)(function (ev) {
    var keyCode = ev.keyCode,
        repeat = ev.repeat,
        target = ev.target;
    var _mutableRef$current10 = mutableRef.current,
        selectedItem = _mutableRef$current10.selectedItem,
        selectedItemLabel = _mutableRef$current10.selectedItemLabel;
    var targetItemNode = findItemNode(target);

    if ((0, _keymap.is)('enter', keyCode) && target.getAttribute('role') !== 'button') {
      if (!repeat) {
        if (selectedItem) {
          var orders = finalizeOrders();
          (0, _handle.forwardCustom)('onComplete', function () {
            return {
              orders: orders
            };
          })({}, editable);
          reset();
          mutableRef.current.needToPreventEvent = true;
          setTimeout(function () {
            announceRef.current.announce(selectedItemLabel + (0, _$L["default"])('move complete'), true);
          }, completeAnnounceDelay);
        }
      } else if (repeat && targetItemNode && !mutableRef.current.timer) {
        mutableRef.current.timer = setTimeout(function () {
          startEditing(targetItemNode);
        }, holdDuration - 300);
      }
    } else if ((0, _keymap.is)('left', keyCode) || (0, _keymap.is)('right', keyCode)) {
      if (selectedItem) {
        if (repeat) {
          SpotlightAccelerator.processKey(ev, moveItemsByKeyDown);
        } else {
          SpotlightAccelerator.reset();
          moveItemsByKeyDown(ev);
        }

        ev.preventDefault();
        ev.stopPropagation();
      }
    }
  }, [editable, finalizeOrders, findItemNode, moveItemsByKeyDown, reset, startEditing]);
  var handleKeyUpCapture = (0, _react.useCallback)(function (ev) {
    if (ev.target.getAttribute('role') === 'button') {
      return;
    }

    clearTimeout(mutableRef.current.timer);
    mutableRef.current.timer = null;

    if (mutableRef.current.needToPreventEvent || mutableRef.current.selectedItem) {
      ev.preventDefault();
      mutableRef.current.needToPreventEvent = false;
    }
  }, []);
  (0, _react.useEffect)(function () {
    if (mutableRef.current.nextSpotlightRect !== null) {
      _spotlight["default"].focusNextFromPoint('down', mutableRef.current.nextSpotlightRect);

      mutableRef.current.nextSpotlightRect = null;
    }
  });
  (0, _react.useEffect)(function () {
    var _wrapperRef$current;

    // Calculate the item width once
    var rtl = scrollContainerHandle.current.rtl;
    var item = (_wrapperRef$current = wrapperRef.current) === null || _wrapperRef$current === void 0 ? void 0 : _wrapperRef$current.children[0];

    if (item && typeof window !== 'undefined') {
      var _wrapperRef$current2;

      var bodyWidth = document.body.getBoundingClientRect().width;
      var neighbor = item.nextElementSibling || item.previousElementSibling;
      mutableRef.current.itemWidth = Math.abs(item.offsetLeft - (neighbor === null || neighbor === void 0 ? void 0 : neighbor.offsetLeft));
      mutableRef.current.centeredOffset = rtl ? bodyWidth - item.getBoundingClientRect().right : item.getBoundingClientRect().left;
      (_wrapperRef$current2 = wrapperRef.current) === null || _wrapperRef$current2 === void 0 ? void 0 : _wrapperRef$current2.style.setProperty('--item-width', mutableRef.current.itemWidth + 'px');
    }
  }, [centered, dataSize, scrollContainerHandle]);
  (0, _react.useEffect)(function () {
    mutableRef.current.spotlightId = scrollContainerRef.current && scrollContainerRef.current.dataset.spotlightId;
  }, [scrollContainerRef]);
  (0, _react.useEffect)(function () {
    var scrollContainer = scrollContainerRef.current;

    if (scrollContainer) {
      scrollContainer.addEventListener('mouseleave', handleMouseLeave);
    }

    return function () {
      if (scrollContainer) {
        scrollContainer.removeEventListener('mouseleave', handleMouseLeave);
      }
    };
  }, [handleMouseLeave, scrollContainerRef]);
  (0, _react.useEffect)(function () {
    if (removeItemFuncRef) {
      removeItemFuncRef.current = removeItem;
    }
  }, [removeItem, removeItemFuncRef]);
  (0, _react.useEffect)(function () {
    // addEventListener to moveItems while scrolled
    var scrollContentNode = scrollContentRef.current;

    var handleMoveItemsByScroll = function handleMoveItemsByScroll() {
      var bodyWidth = document.body.getBoundingClientRect().width;
      var _mutableRef$current11 = mutableRef.current,
          lastMouseClientX = _mutableRef$current11.lastMouseClientX,
          selectedItem = _mutableRef$current11.selectedItem;
      var _scrollContainerHandl = scrollContainerHandle.current,
          isHoveringToScroll = _scrollContainerHandl.isHoveringToScroll,
          rtl = _scrollContainerHandl.rtl;

      if (selectedItem && mutableRef.current.lastInputType !== 'key') {
        mutableRef.current.lastInputType = 'scroll';

        if (isHoveringToScroll) {
          var toIndex = getNextIndexFromPosition(lastMouseClientX, 0);
          moveItems(!rtl ^ !(lastMouseClientX > bodyWidth / 2) ? toIndex + 1 : toIndex - 1);
        } else {
          moveItems(getNextIndexFromPosition(lastMouseClientX, 0.33));
        }
      }
    };

    scrollContentNode.addEventListener('scroll', handleMoveItemsByScroll);
    return function () {
      scrollContentNode.removeEventListener('scroll', handleMoveItemsByScroll);
    };
  }, [getNextIndexFromPosition, moveItems, scrollContainerHandle, scrollContentRef]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(TouchableDiv, {
    holdConfig: holdConfig,
    className: (0, _classnames["default"])(mergedCss.wrapper, _defineProperty({}, mergedCss.centered, centered)),
    onClickCapture: handleClickCapture,
    onHoldStart: handleHoldStart,
    onKeyDownCapture: handleKeyDownCapture,
    onKeyUpCapture: handleKeyUpCapture,
    onMouseDown: handleMouseDown,
    onMouseMove: handleMouseMove,
    ref: wrapperRef,
    children: [children, /*#__PURE__*/(0, _jsxRuntime.jsx)(_AnnounceDecorator.Announce, {
      ref: announceRef
    }, "editable-wrapper-announce")]
  });
};

exports.EditableWrapper = EditableWrapper;
EditableWrapper.displayName = 'EditableWrapper';
EditableWrapper.propTypes =
/** @lends sandstone/Scroller.EditableWrapper.prototype */
{
  /**
   * Enables editing items in the scroller.
   * You can specify props for editable scroller as an object.
   * See the datails in [EditableShape]{@link sandstone/Scroller.EditableShape}
   *
   * @type {sandstone/Scroller.EditableShape}
   * @public
   */
  editable: EditableShape,

  /**
   * Obtains a reference to the scroll container handle.
   *
   * @type {Function|Object}
   * @public
   */
  scrollContainerHandle: _propTypes["default"].ref,

  /**
   * Obtains a reference to the scroll container node.
   *
   * @type {Function|Object}
   * @public
   */
  scrollContainerRef: _propTypes["default"].ref,

  /**
   * Obtains a reference to the scroll content node.
   *
   * @type {Function|Object}
   * @public
   */
  scrollContentRef: _propTypes["default"].ref
};
var _default = EditableWrapper;
exports["default"] = _default;