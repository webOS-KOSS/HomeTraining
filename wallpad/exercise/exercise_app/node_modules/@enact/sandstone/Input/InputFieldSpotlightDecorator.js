"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.InputSpotlightDecorator = void 0;

var _handle = require("@enact/core/handle");

var _hoc = _interopRequireDefault(require("@enact/core/hoc"));

var _keymap = require("@enact/core/keymap");

var _spotlight = require("@enact/spotlight");

var _Pause = _interopRequireDefault(require("@enact/spotlight/Pause"));

var _Spottable = _interopRequireDefault(require("@enact/spotlight/Spottable"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = require("react");

var _pointer = require("./pointer");

var _jsxRuntime = require("react/jsx-runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var isBubbling = function isBubbling(ev) {
  return ev.currentTarget !== ev.target;
}; // A regex to check for input types that allow selectionStart


var SELECTABLE_TYPES = /text|password|search|tel|url/;

var isSelectionAtLocation = function isSelectionAtLocation(target, location) {
  if (SELECTABLE_TYPES.test(target.type)) {
    return target.selectionStart === location;
  } else {
    return true;
  }
};

var handleKeyDown = (0, _handle.handle)((0, _handle.forwardWithPrevent)('onKeyDown'), (0, _handle.call)('onKeyDown'));
/**
 * Default config for [InputSpotlightDecorator]{@link sandstone/Input.InputSpotlightDecorator}
 *
 * @memberof sandstone/Input/InputSpotlightDecorator.InputSpotlightDecorator
 * @hocconfig
 */

var defaultConfig = {
  /**
   * Suppress the pointer lock behavior of sandstone input
   *
   * @type {Boolean}
   * @default false
   * @memberof sandstone/Input/InputSpotlightDecorator.InputSpotlightDecorator.defaultConfig
  */
  noLockPointer: false
};
/**
 * A higher-order component that manages the
 * spotlight behavior for an {@link sandstone/Input.Input}
 *
 * @class InputSpotlightDecorator
 * @memberof sandstone/Input/InputSpotlightDecorator
 * @hoc
 * @private
 */

var InputSpotlightDecorator = (0, _hoc["default"])(defaultConfig, function (config, Wrapped) {
  var _class;

  var noLockPointer = config.noLockPointer;
  var Component = (0, _Spottable["default"])({
    emulateMouse: false
  }, Wrapped);
  var forwardBlur = (0, _handle.forward)('onBlur');
  var forwardMouseDown = (0, _handle.forward)('onMouseDown');
  var forwardFocus = (0, _handle.forward)('onFocus');
  var forwardKeyUp = (0, _handle.forward)('onKeyUp');
  return _class = /*#__PURE__*/function (_ReactComponent) {
    _inherits(_class, _ReactComponent);

    var _super = _createSuper(_class);

    function _class(props) {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this, props);

      _this.updateFocus = function () {
        // focus node if `InputSpotlightDecorator` is pausing Spotlight or if Spotlight is paused
        if (_this.node && _spotlight.Spotlight.getCurrent() !== _this.node && (_this.paused.isPaused() || !_spotlight.Spotlight.isPaused())) {
          if (_this.fromMouse) {
            _this.node.focus({
              preventScroll: true
            });
          } else {
            _this.node.focus();
          }
        }

        var focusChanged = _this.focused !== _this.prevStatus.focused;

        if (focusChanged) {
          if (_this.focused === 'input') {
            (0, _handle.forwardCustom)('onActivate')(null, _this.props);

            if (!noLockPointer) {
              (0, _pointer.lockPointer)(_this.node);
            }

            _this.paused.pause();
          } else if (_this.prevStatus.focused === 'input') {
            (0, _handle.forwardCustom)('onDeactivate')(null, _this.props);

            if (!noLockPointer) {
              (0, _pointer.releasePointer)(_this.prevStatus.node);
            }

            _this.paused.resume();
          }
        }

        _this.prevStatus.focused = _this.focused;
        _this.prevStatus.node = _this.node;
      };

      _this.focus = function (focused, node, fromMouse) {
        _this.focused = focused;
        _this.node = node;
        _this.fromMouse = fromMouse;

        _this.updateFocus();
      };

      _this.blur = function () {
        if (_this.focused || _this.node) {
          _this.focused = null;
          _this.node = null;

          _this.updateFocus();
        }
      };

      _this.focusDecorator = function (decorator) {
        _this.focus('decorator', decorator, false);
      };

      _this.focusInput = function (decorator, fromMouse) {
        _this.focus('input', decorator.querySelector('input'), fromMouse);
      };

      _this.onBlur = function (ev) {
        if (!_this.props.autoFocus) {
          if (isBubbling(ev)) {
            if (_spotlight.Spotlight.getPointerMode()) {
              _this.blur();

              forwardBlur(ev, _this.props);
            } else {
              _this.focused = 'decorator';
              _this.node = ev.currentTarget;
              _this.fromMouse = false;
              ev.stopPropagation();
            }
          } else if (!ev.currentTarget.contains(ev.relatedTarget)) {
            // Blurring decorator but not focusing input
            forwardBlur(ev, _this.props);

            _this.blur();
          }
        } else if (isBubbling(ev)) {
          if (_this.focused === 'input' && _this.node === ev.target && ev.currentTarget !== ev.relatedTarget) {
            _this.blur();

            forwardBlur(ev, _this.props);
          } else {
            _this.focusDecorator(ev.currentTarget);

            ev.stopPropagation();

            _this.blur();
          }
        }
      };

      _this.onMouseDown = function (ev) {
        var _this$props = _this.props,
            disabled = _this$props.disabled,
            spotlightDisabled = _this$props.spotlightDisabled;

        _this.setDownTarget(ev); // focus the <input> whenever clicking on any part of the component to ensure both that
        // the <input> has focus and Spotlight is paused.


        if (!disabled && !spotlightDisabled) {
          _this.focusInput(ev.currentTarget, true);
        }

        forwardMouseDown(ev, _this.props);
      };

      _this.onFocus = function (ev) {
        forwardFocus(ev, _this.props); // when in autoFocus mode, focusing the decorator directly will cause it to
        // forward the focus onto the <input>

        if (!isBubbling(ev) && _this.props.autoFocus && _this.focused === null && !_spotlight.Spotlight.getPointerMode()) {
          _this.focusInput(ev.currentTarget, false);

          ev.stopPropagation();
        }
      };

      _this.onKeyUp = function (ev) {
        var dismissOnEnter = _this.props.dismissOnEnter;
        var currentTarget = ev.currentTarget,
            keyCode = ev.keyCode,
            target = ev.target; // verify that we have a matching pair of key down/up events to avoid adjusting focus
        // when the component received focus mid-press

        if (target === _this.downTarget) {
          _this.downTarget = null;

          if (!_this.props.disabled) {
            if (_this.focused === 'input' && dismissOnEnter && (0, _keymap.is)('enter', keyCode)) {
              _this.focusDecorator(currentTarget); // prevent Enter onKeyPress which triggers an onMouseDown via Spotlight


              ev.preventDefault();
            } else if (_this.focused !== 'input' && (0, _keymap.is)('enter', keyCode)) {
              _this.focusInput(currentTarget, false);
            }
          }
        }

        forwardKeyUp(ev, _this.props);
      };

      _this.focused = null;
      _this.node = null;
      _this.fromMouse = false;
      _this.paused = new _Pause["default"]('InputSpotlightDecorator');
      _this.handleKeyDown = handleKeyDown.bind(_assertThisInitialized(_this));
      _this.prevStatus = {
        focused: null,
        node: null
      };
      return _this;
    }

    _createClass(_class, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.paused.resume();

        if (this.focused === 'input') {
          var onSpotlightDisappear = this.props.onSpotlightDisappear;

          if (onSpotlightDisappear) {
            onSpotlightDisappear();
          }

          if (!noLockPointer) {
            (0, _pointer.releasePointer)(this.node);
          }
        }
      }
    }, {
      key: "onKeyDown",
      value: function onKeyDown(ev) {
        var currentTarget = ev.currentTarget,
            keyCode = ev.keyCode,
            target = ev.target; // cache the target if this is the first keyDown event to ensure the component had focus
        // when the key interaction started

        this.setDownTarget(ev);

        if (this.focused === 'input') {
          var isDown = (0, _keymap.is)('down', keyCode);
          var isLeft = (0, _keymap.is)('left', keyCode);
          var isRight = (0, _keymap.is)('right', keyCode);
          var isUp = (0, _keymap.is)('up', keyCode); // move spotlight

          var shouldSpotlightMove = // No value exists! (Can happen when disabled)
          target.value == null || // on left + at beginning of selection
          isLeft && isSelectionAtLocation(target, 0) || // on right + at end of selection (note: fails on non-selectable types usually)
          isRight && isSelectionAtLocation(target, target.value.length) || // on up
          isUp || // on down
          isDown; // prevent modifying the value via 5-way for numeric fields

          if ((isUp || isDown) && target.type === 'number') {
            ev.preventDefault();
          }

          if (shouldSpotlightMove) {
            var direction = (0, _spotlight.getDirection)(keyCode);
            var getPointerMode = _spotlight.Spotlight.getPointerMode,
                move = _spotlight.Spotlight.move,
                setPointerMode = _spotlight.Spotlight.setPointerMode;

            if (getPointerMode()) {
              setPointerMode(false);
            }

            (0, _handle.stopImmediate)(ev);
            this.paused.resume(); // Move spotlight in the keypress direction

            if (move(direction)) {
              // if successful, reset the internal state
              this.blur();
            } else {
              // if there is no other spottable elements, focus `InputDecorator` instead
              this.focusDecorator(currentTarget);
            }
          } else if (isLeft || isRight) {
            // prevent 5-way nav for left/right keys within the <input>
            (0, _handle.stopImmediate)(ev);
          }
        }
      }
    }, {
      key: "setDownTarget",
      value: function setDownTarget(ev) {
        var repeat = ev.repeat,
            target = ev.target;

        if (!repeat) {
          this.downTarget = target;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var props = Object.assign({}, this.props);
        delete props.autoFocus;
        delete props.onActivate;
        delete props.onDeactivate;
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, _objectSpread(_objectSpread({}, props), {}, {
          onBlur: this.onBlur,
          onMouseDown: this.onMouseDown,
          onFocus: this.onFocus,
          onKeyDown: this.handleKeyDown,
          onKeyUp: this.onKeyUp
        }));
      }
    }]);

    return _class;
  }(_react.Component), _class.displayName = 'InputSpotlightDecorator', _class.propTypes =
  /** @lends sandstone/Input/InputSpotlightDecorator.InputSpotlightDecorator.prototype */
  {
    /**
     * Focuses the <input> when the decorator is focused via 5-way.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    autoFocus: _propTypes["default"].bool,

    /**
     * Applies a disabled style and the control becomes non-interactive.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    disabled: _propTypes["default"].bool,

    /**
     * Blurs the input when the "enter" key is pressed.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    dismissOnEnter: _propTypes["default"].bool,

    /**
     * Called when the internal <input> is focused.
     *
     * @type {Function}
     * @param {Object} event
     * @public
     */
    onActivate: _propTypes["default"].func,

    /**
     * Called when the internal <input> loses focus.
     *
     * @type {Function}
     * @param {Object} event
     * @public
     */
    onDeactivate: _propTypes["default"].func,

    /**
     * Called when the component is removed while retaining focus.
     *
     * @type {Function}
     * @param {Object} event
     * @public
     */
    onSpotlightDisappear: _propTypes["default"].func,

    /**
     * Disables spotlight navigation into the component.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    spotlightDisabled: _propTypes["default"].bool
  }, _class;
});
exports.InputSpotlightDecorator = InputSpotlightDecorator;
var _default = InputSpotlightDecorator;
exports["default"] = _default;