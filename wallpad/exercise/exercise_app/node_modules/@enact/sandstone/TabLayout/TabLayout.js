"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Tab", {
  enumerable: true,
  get: function get() {
    return _Tab["default"];
  }
});
exports["default"] = exports.TabLayoutDecorator = exports.TabLayoutContext = exports.TabLayoutBase = exports.TabLayout = void 0;

var _handle = require("@enact/core/handle");

var _keymap = require("@enact/core/keymap");

var _kind = _interopRequireDefault(require("@enact/core/kind"));

var _util = require("@enact/core/util");

var _spotlight = _interopRequireWildcard(require("@enact/spotlight"));

var _target = require("@enact/spotlight/src/target");

var _SpotlightContainerDecorator = _interopRequireDefault(require("@enact/spotlight/SpotlightContainerDecorator"));

var _Changeable = require("@enact/ui/Changeable");

var _Layout = require("@enact/ui/Layout");

var _resolution = require("@enact/ui/resolution");

var _Toggleable = _interopRequireDefault(require("@enact/ui/Toggleable"));

var _Touchable = _interopRequireDefault(require("@enact/ui/Touchable"));

var _ViewManager = _interopRequireDefault(require("@enact/ui/ViewManager"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _compose = _interopRequireDefault(require("ramda/src/compose"));

var _react = require("react");

var _ThemeDecorator = require("../ThemeDecorator");

var _RefocusDecorator = _interopRequireWildcard(require("./RefocusDecorator"));

var _TabGroup = _interopRequireDefault(require("./TabGroup"));

var _Tab = _interopRequireDefault(require("./Tab"));

var _TabLayoutModule = _interopRequireDefault(require("./TabLayout.module.css"));

var _PopupTabLayoutModule = _interopRequireDefault(require("../PopupTabLayout/PopupTabLayout.module.css"));

var _jsxRuntime = require("react/jsx-runtime");

var _excluded = ["children", "collapsed", "css", "data-spotlight-id", "dimensions", "handleClick", "handleEnter", "handleFlick", "handleFocus", "handleTabsTransitionEnd", "index", "onCollapse", "onSelect", "orientation", "tabOrientation", "tabSize", "tabs", "type"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TabLayoutContext = /*#__PURE__*/(0, _react.createContext)(null);
exports.TabLayoutContext = TabLayoutContext;
var TouchableCell = (0, _Touchable["default"])(_Layout.Cell);

var isTouchMode = function isTouchMode() {
  return (0, _ThemeDecorator.getLastInputType)() === 'touch';
};
/**
 * Tabbed Layout component.
 *
 * Example:
 *
 * ```jsx
 * 	<TabLayout>
 * 		<Tab title="Tab One">
 * 			<Item>Hello</Item>
 * 		</Tab>
 * 		<Tab title="Tab Two">
 * 			<Item>Goodbye</Item>
 * 		</Tab>
 * 	</TabLayout>
 * ```
 *
 * @class TabLayout
 * @memberof sandstone/TabLayout
 * @ui
 * @public
 */


var TabLayoutBase = (0, _kind["default"])({
  name: 'TabLayout',
  propTypes:
  /** @lends sandstone/TabLayout.TabLayout.prototype */
  {
    /**
     * Sets where this component should attach its tabs and animations.
     *
     * "left" and "right" represent true screen left and screen right, while "start" represents
     * screen left in LTR and screen right in RTL. "end" is the reverse: screen right for LTR
     * and screen left for RTL.
     *
     * @type {('left'|'right'|'start'|'end')}
     * @default 'start'
     * @private
     */
    anchorTo: _propTypes["default"].oneOf(['left', 'right', 'start', 'end']),

    /**
     * Collection of [Tabs]{@link sandstone/TabLayout.Tab} to render.
     *
     * @type {Node}
     * @public
     */
    children: _propTypes["default"].node,

    /**
     * Collapses the vertical tab list into icons only.
     *
     * Only applies to `orientation="vertical"`.  If the tabs do not include icons, a single
     * collapsed icon will be shown.
     *
     * @type {Boolean}
     * @public
     */
    collapsed: _propTypes["default"].bool,

    /**
     * Customizes the component by mapping the supplied collection of CSS class names to the
     * corresponding internal elements and states of this component.
     *
     * The following classes are supported:
     *
     * @type {Object}
     * @public
     */
    css: _propTypes["default"].object,
    'data-spotlight-id': _propTypes["default"].string,

    /**
     * Specify dimensions for the layout areas.
     *
     * All 4 combinations must me supplied: each of the elements, tabs and content in both
     * collapsed and expanded state.
     *
     * @type {{tabs: {collapsed: Number, normal: Number}, content: {expanded: number, normal: number}}}
     * @default {
     * 	tabs: {
     * 		collapsed: 228,
     * 		normal: 882
     * 	},
     * 	content: {
     * 		expanded: null,
     * 		normal: null
     * 	}
     * }
     * @private
     */
    dimensions: _propTypes["default"].shape({
      content: _propTypes["default"].shape({
        expanded: _propTypes["default"].number,
        normal: _propTypes["default"].number
      }).isRequired,
      tabs: _propTypes["default"].shape({
        collapsed: _propTypes["default"].number,
        normal: _propTypes["default"].number
      }).isRequired
    }),

    /**
     * The currently selected tab.
     *
     * @type {Number}
     * @default 0
     * @public
     */
    index: _propTypes["default"].number,

    /**
     * Called when the tabs are collapsed.
     *
     * @type {Function}
     * @public
     */
    onCollapse: _propTypes["default"].func,

    /**
     * Called when the tabs are expanded.
     *
     * @type {Function}
     * @public
     */
    onExpand: _propTypes["default"].func,

    /**
     * Called when a tab is selected
     *
     * @type {Function}
     * @public
    */
    onSelect: _propTypes["default"].func,

    /**
     * Called when the tab collapse or expand animation completes.
     *
     * Event payload includes:
     * * `type` - Always set to "onTabAnimationEnd"
     * * `collapsed` - `true` when the tabs are collapsed
     *
     * @type {Function}
     * @public
     */
    onTabAnimationEnd: _propTypes["default"].func,

    /**
     * Orientation of the tabs.
     *
     * @type {('horizontal'|'vertical')}
     * @default 'vertical'
     * @public
     */
    orientation: _propTypes["default"].oneOf(['horizontal', 'vertical']),

    /**
     * Assign a custom size to horizontal tabs.
     *
     * Tabs in the horizontal orientation automatically stretch to fill the available width.
     * Leave this prop blank to use the default auto-sizing behavior.
     * Tabs may also be set to a finite width using this property. This accepts numeric pixel
     * values. Be mindful of the value you provide as values that are too wide will run off the
     * edge of the screen.
     *
     * Only applies to `orientation="horizontal"` at this time.
     *
     * @type {Number}
     * @public
     */
    tabSize: _propTypes["default"].number,

    /**
     * Type of TabLayout.
     *
     * @type {('normal'|'popup')}
     * @default 'normal'
     * @private
     */
    type: _propTypes["default"].oneOf(['normal', 'popup'])
  },
  defaultProps: {
    anchorTo: 'start',
    dimensions: {
      tabs: {
        collapsed: 216,
        normal: 882
      },
      content: {
        expanded: null,
        normal: null
      }
    },
    index: 0,
    orientation: 'vertical',
    type: 'normal'
  },
  styles: {
    css: _TabLayoutModule["default"],
    className: 'tabLayout',
    publicClassNames: ['bg', 'button', 'client', 'collapsed', 'content', 'selected', 'tab', 'tabGroup', 'tabLayout', 'tabs', 'tabsExpanded', 'vertical']
  },
  handlers: {
    onKeyDown: function onKeyDown(ev, props) {
      var keyCode = ev.keyCode,
          target = ev.target;
      var collapsed = props.collapsed,
          orientation = props.orientation,
          spotlightId = props['data-spotlight-id'];
      var direction = (0, _spotlight.getDirection)(keyCode);

      if ((0, _handle.forwardWithPrevent)('onKeyDown', ev, props) && direction && collapsed && orientation === 'vertical' && document.querySelector("[data-spotlight-id='".concat(spotlightId, "']")).contains(target) && target.tagName !== 'INPUT') {
        _spotlight["default"].setPointerMode(false);

        ev.preventDefault();

        if (_spotlight["default"].move(direction)) {
          ev.stopPropagation();
        } else if (document.querySelector("[data-spotlight-id='".concat(spotlightId, "'] .").concat(_TabLayoutModule["default"].content)).contains(target)) {
          _spotlight["default"].set(spotlightId, {
            navigableFilter: null
          });

          var nextTarget = (0, _target.getTargetByDirectionFromElement)(direction, target);

          _spotlight["default"].set(spotlightId, {
            navigableFilter: (0, _RefocusDecorator.getNavigableFilter)(spotlightId, collapsed)
          });

          if (nextTarget && document.querySelector(".".concat(_TabLayoutModule["default"].tabs)).contains(nextTarget)) {
            (0, _handle.forward)('onExpand', ev, props);
          }
        }
      }
    },
    onKeyUp: function onKeyUp(ev, props) {
      var keyCode = ev.keyCode,
          target = ev.target;
      var collapsed = props.collapsed,
          spotlightId = props['data-spotlight-id'],
          type = props.type;
      var popupPanelRef = document.querySelector("[data-spotlight-id='".concat(spotlightId, "'] .").concat(_PopupTabLayoutModule["default"].panel));

      if ((0, _handle.forwardWithPrevent)('onKeyUp', ev, props) && type === 'popup' && (0, _keymap.is)('cancel')(keyCode) && popupPanelRef.contains(target) && popupPanelRef.dataset.index === '0') {
        if (collapsed) {
          (0, _handle.forward)('onExpand', ev, props);
        }

        _spotlight["default"].move('left');

        ev.stopPropagation();
      }
    },
    onSelect: (0, _handle.handle)((0, _handle.forwardCustom)('onSelect', function (_ref) {
      var selected = _ref.selected;
      return {
        index: selected
      };
    })),
    handleTabsTransitionEnd: (0, _handle.handle)((0, _handle.forward)('onTransitionEnd'), (0, _handle.forProp)('orientation', 'vertical'), // Validate the transition is from the root node
    function (ev) {
      return ev.target.classList.contains(_TabLayoutModule["default"].tabs);
    }, (0, _handle.adaptEvent)(function (ev, _ref2) {
      var collapsed = _ref2.collapsed;
      return {
        type: 'onTabAnimationEnd',
        collapsed: Boolean(collapsed)
      };
    }, (0, _handle.forward)('onTabAnimationEnd'))),
    handleFlick: function handleFlick(_ref3, _ref4) {
      var direction = _ref3.direction,
          velocityX = _ref3.velocityX;
      var collapsed = _ref4.collapsed,
          onCollapse = _ref4.onCollapse,
          onExpand = _ref4.onExpand;

      // See the global class 'spotlight-input-touch' to check the input type is touch
      if (isTouchMode() && direction === 'horizontal') {
        if (!collapsed && velocityX < 0) {
          onCollapse();
        } else if (collapsed && velocityX > 0) {
          onExpand();
        }
      }
    },
    handleClick: (0, _handle.handle)(isTouchMode, (0, _handle.forward)('onExpand')),
    handleFocus: (0, _handle.handle)((0, _handle.not)(isTouchMode), (0, _handle.forward)('onExpand')),
    handleEnter: function handleEnter(ev, props) {
      var index = ev.index,
          previousIndex = ev.previousIndex;

      if (index > previousIndex) {
        (0, _handle.forward)('onCollapse', ev, props);
      }
    }
  },
  computed: {
    children: function children(_ref5) {
      var _children = _ref5.children;
      return (0, _util.mapAndFilterChildren)(_children, function (child) {
        return /*#__PURE__*/(0, _jsxRuntime.jsx)(_react.Fragment, {
          children: child.props.children
        });
      });
    },
    className: function className(_ref6) {
      var collapsed = _ref6.collapsed,
          anchorTo = _ref6.anchorTo,
          orientation = _ref6.orientation,
          styler = _ref6.styler;
      return styler.append({
        collapsed: orientation === 'vertical' && collapsed
      }, "anchor".concat((0, _util.cap)(anchorTo)), orientation);
    },
    style: function style(_ref7) {
      var dimensions = _ref7.dimensions,
          orientation = _ref7.orientation,
          _style = _ref7.style;
      return _objectSpread(_objectSpread({}, _style), {}, {
        '--tablayout-expand-collapse-diff': orientation === 'vertical' ? (0, _resolution.scaleToRem)(dimensions.tabs.normal - dimensions.tabs.collapsed) : 0
      });
    },
    tabOrientation: function tabOrientation(_ref8) {
      var orientation = _ref8.orientation;
      return orientation === 'vertical' ? 'horizontal' : 'vertical';
    },
    tabs: function tabs(_ref9) {
      var children = _ref9.children;
      var tabs = (0, _util.mapAndFilterChildren)(children, function (child) {
        return Object.keys(child.props).filter(function (prop) {
          return prop !== 'children' && prop !== 'id';
        }).reduce(function (obj, key) {
          return _objectSpread(_objectSpread({}, obj), {}, _defineProperty({}, key, child.props[key]));
        }, {});
      });
      return tabs;
    }
  },
  render: function render(_ref10) {
    var children = _ref10.children,
        collapsed = _ref10.collapsed,
        css = _ref10.css,
        spotlightId = _ref10['data-spotlight-id'],
        dimensions = _ref10.dimensions,
        handleClick = _ref10.handleClick,
        handleEnter = _ref10.handleEnter,
        handleFlick = _ref10.handleFlick,
        handleFocus = _ref10.handleFocus,
        handleTabsTransitionEnd = _ref10.handleTabsTransitionEnd,
        index = _ref10.index,
        onCollapse = _ref10.onCollapse,
        onSelect = _ref10.onSelect,
        orientation = _ref10.orientation,
        tabOrientation = _ref10.tabOrientation,
        tabSize = _ref10.tabSize,
        tabs = _ref10.tabs,
        type = _ref10.type,
        rest = _objectWithoutProperties(_ref10, _excluded);

    delete rest.anchorTo;
    delete rest.onExpand;
    delete rest.onTabAnimationEnd;
    var contentSize = collapsed ? dimensions.content.expanded : dimensions.content.normal;
    var isVertical = orientation === 'vertical';
    var ContentCell = isVertical ? TouchableCell : _Layout.Cell;
    var contentCellProps = isVertical ? {
      onFlick: handleFlick
    } : null; // Props that are shared between both of the rendered TabGroup components

    var tabGroupProps = {
      css: css,
      onClick: collapsed ? handleClick : null,
      onFocus: collapsed ? handleFocus : null,
      onFocusTab: onSelect,
      onSelect: onSelect,
      orientation: orientation,
      selectedIndex: index,
      tabs: tabs
    }; // In vertical orientation, render two sets of tabs, one just icons, one with icons and text.

    return /*#__PURE__*/(0, _jsxRuntime.jsx)(TabLayoutContext.Provider, {
      value: handleEnter,
      children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_Layout.Layout, _objectSpread(_objectSpread({}, rest), {}, {
        orientation: tabOrientation,
        "data-spotlight-id": spotlightId,
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
          className: css.tabs,
          shrink: true,
          onTransitionEnd: handleTabsTransitionEnd,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_TabGroup["default"], _objectSpread(_objectSpread({}, tabGroupProps), {}, {
            collapsed: isVertical,
            spotlightId: (0, _RefocusDecorator.getTabsSpotlightId)(spotlightId, isVertical),
            tabSize: !isVertical ? tabSize : null,
            spotlightDisabled: !collapsed && isVertical
          }))
        }), isVertical ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Layout.Cell, {
          className: css.tabs + ' ' + css.tabsExpanded,
          size: dimensions.tabs.normal,
          children: /*#__PURE__*/(0, _jsxRuntime.jsx)(_TabGroup["default"], _objectSpread(_objectSpread({}, tabGroupProps), {}, {
            spotlightId: (0, _RefocusDecorator.getTabsSpotlightId)(spotlightId, false),
            spotlightDisabled: collapsed
          }))
        }) : null, /*#__PURE__*/(0, _jsxRuntime.jsx)(ContentCell, _objectSpread(_objectSpread({
          size: isVertical ? contentSize : null,
          className: css.content,
          component: _ViewManager["default"],
          index: index,
          noAnimation: true,
          onFocus: type === 'normal' && !collapsed ? onCollapse : null,
          orientation: orientation
        }, contentCellProps), {}, {
          children: children
        }))]
      }))
    });
  }
});
exports.TabLayoutBase = TabLayoutBase;
var TabLayoutDecorator = (0, _compose["default"])((0, _Toggleable["default"])({
  prop: 'collapsed',
  activate: 'onCollapse',
  deactivate: 'onExpand'
}), (0, _Changeable.Changeable)({
  prop: 'index',
  change: 'onSelect'
}), _RefocusDecorator["default"], (0, _SpotlightContainerDecorator["default"])({
  // using last-focused so we return to the last focused if it exists but fall through to
  // default element if no focus has ocurred yet (e.g. on mount)
  enterTo: 'last-focused',
  // favor the content when collapsed and the tabs otherwise
  defaultElement: [".".concat(_TabLayoutModule["default"].horizontal, " .").concat(_TabLayoutModule["default"].tabs, " *"), ".".concat(_TabLayoutModule["default"].collapsed, " .").concat(_TabLayoutModule["default"].content, " *"), ".".concat(_TabLayoutModule["default"].tabsExpanded, " *")]
})); // Currently not documenting the base output since it's not exported

exports.TabLayoutDecorator = TabLayoutDecorator;
var TabLayout = TabLayoutDecorator(TabLayoutBase);
/**
 * A shortcut to access {@link sandstone/TabLayout.Tab}
 *
 * @name Tab
 * @type {sandstone/TabLayout.Tab}
 * @static
 * @memberof sandstone/TabLayout.TabLayout
 */

exports.TabLayout = TabLayout;
TabLayout.Tab = _Tab["default"];
var _default = TabLayout;
exports["default"] = _default;