"use strict";

var _react = require("@testing-library/react");

var _react2 = require("react");

var _ = _interopRequireDefault(require("../"));

var _jsxRuntime = require("react/jsx-runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

describe('DebounceDecorator', function () {
  beforeEach(function () {
    jest.useFakeTimers();
  });
  afterEach(function () {
    jest.useRealTimers();
  });
  test('should emit the event after the delay', function (done) {
    var Component = (0, _["default"])({
      debounce: 'onChange',
      delay: 100
    }, function Base(_ref) {
      var onChange = _ref.onChange;
      var ref = (0, _react2.useRef)(null);
      (0, _react2.useEffect)(function () {
        var current = ref.current;
        current.addEventListener('onChange', onChange);
        return function () {
          current.removeEventListener('onChange', onChange);
        };
      }, [onChange]);
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        ref: ref,
        children: "Test"
      });
    });
    var spy = jest.fn();
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onChange: spy
    }));

    var elem = _react.screen.getByText('Test');

    (0, _react.fireEvent)(elem, (0, _react.createEvent)('onChange', elem));
    expect(spy).not.toHaveBeenCalled();
    (0, _react.act)(function () {
      return jest.advanceTimersByTime(150);
    });
    expect(spy).toHaveBeenCalled();
    done();
  });
  test('should restart the delay if another event occurs before timeout', function (done) {
    var Component = (0, _["default"])({
      debounce: 'onChange',
      delay: 100
    }, function Base(_ref2) {
      var onChange = _ref2.onChange;
      var ref = (0, _react2.useRef)(null);
      (0, _react2.useEffect)(function () {
        var current = ref.current;
        current.addEventListener('onChange', onChange);
        return function () {
          current.removeEventListener('onChange', onChange);
        };
      }, [onChange]);
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        ref: ref,
        children: "Test"
      });
    });
    var spy = jest.fn();
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onChange: spy
    }));
    (0, _react.act)(function () {
      return jest.advanceTimersByTime(50);
    });
    expect(spy).not.toHaveBeenCalled();

    var elem = _react.screen.getByText('Test');

    (0, _react.fireEvent)(elem, (0, _react.createEvent)('onChange', elem));
    (0, _react.act)(function () {
      return jest.advanceTimersByTime(75);
    });
    expect(spy).not.toHaveBeenCalled();
    (0, _react.act)(function () {
      return jest.advanceTimersByTime(75);
    });
    expect(spy).toHaveBeenCalled();
    done();
  });
  test('should not emit the event if the cancel event occurs before the delay', function (done) {
    var Component = (0, _["default"])({
      cancel: 'onCancel',
      debounce: 'onChange',
      delay: 100
    }, function Base(_ref3) {
      var onCancel = _ref3.onCancel,
          onChange = _ref3.onChange;
      var ref = (0, _react2.useRef)(null);
      (0, _react2.useEffect)(function () {
        var current = ref.current;
        current.addEventListener('onChange', onChange);
        current.addEventListener('onCancel', onCancel);
        return function () {
          current.removeEventListener('onChange', onChange);
          current.removeEventListener('onCancel', onCancel);
        };
      }, [onCancel, onChange]);
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        ref: ref,
        children: "Test"
      });
    });
    var spy = jest.fn();
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onChange: spy
    }));

    var elem = _react.screen.getByText('Test');

    (0, _react.fireEvent)(elem, (0, _react.createEvent)('onChange', elem));
    (0, _react.fireEvent)(elem, (0, _react.createEvent)('onCancel', elem));
    expect(spy).not.toHaveBeenCalled();
    (0, _react.act)(function () {
      return jest.advanceTimersByTime(150);
    });
    expect(spy).not.toHaveBeenCalled();
    done();
  });
  test('should emit the onCancel event immediately', function () {
    var Component = (0, _["default"])({
      cancel: 'onCancel',
      debounce: 'onChange',
      delay: 100
    }, function Base(_ref4) {
      var onCancel = _ref4.onCancel;
      var ref = (0, _react2.useRef)(null);
      (0, _react2.useEffect)(function () {
        var current = ref.current;
        current.addEventListener('onCancel', onCancel);
        return function () {
          current.removeEventListener('onCancel', onCancel);
        };
      }, [onCancel]);
      return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", {
        ref: ref,
        children: "Test"
      });
    });
    var spy = jest.fn();
    (0, _react.render)( /*#__PURE__*/(0, _jsxRuntime.jsx)(Component, {
      onCancel: spy
    }));

    var elem = _react.screen.getByText('Test');

    (0, _react.fireEvent)(elem, (0, _react.createEvent)('onCancel', elem));
    expect(spy).toHaveBeenCalled();
  });
});